// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
// extern void _gotk4_gtksource5_CompletionContext_ConnectProviderModelChanged(gpointer, GtkSourceCompletionProvider*, GListModel*, guintptr);
import "C"

// GType values.
var (
	GTypeCompletionContext = coreglib.Type(C.gtk_source_completion_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCompletionContext, F: marshalCompletionContext},
	})
}

// CompletionContextOverrides contains methods that are overridable.
type CompletionContextOverrides struct {
}

func defaultCompletionContextOverrides(v *CompletionContext) CompletionContextOverrides {
	return CompletionContextOverrides{}
}

// CompletionContext: context of a completion.
//
// GtkSourceCompletionContext contains information about an attept to display
// completion proposals to the user based on typed text in the view.
//
// When typing, completion may use registered completionprovider to
// determine if there may be results which could be displayed. If so,
// a GtkSourceCompletionContext is created with information that is provided to
// the completionprovider to populate results which might be useful to the user.
//
// completionprovider are expected to provide gio.ListModel with
// completionproposal which may be joined together in a list of results for
// the user. They are also responsible for how the contents are displayed using
// completioncell which allows for some level of customization.
type CompletionContext struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*CompletionContext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CompletionContext, *CompletionContextClass, CompletionContextOverrides](
		GTypeCompletionContext,
		initCompletionContextClass,
		wrapCompletionContext,
		defaultCompletionContextOverrides,
	)
}

func initCompletionContextClass(gclass unsafe.Pointer, overrides CompletionContextOverrides, classInitFunc func(*CompletionContextClass)) {
	if classInitFunc != nil {
		class := (*CompletionContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCompletionContext(obj *coreglib.Object) *CompletionContext {
	return &CompletionContext{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalCompletionContext(p uintptr) (interface{}, error) {
	return wrapCompletionContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectProviderModelChanged is emitted when a provider changes a model.
//
// This signal is primarily useful for SourceCompletionProvider's that want to
// track other providers in context. For example, it can be used to create a
// "top results" provider.
func (self *CompletionContext) ConnectProviderModelChanged(f func(provider CompletionProviderer, model gio.ListModeller)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "provider-model-changed", false, unsafe.Pointer(C._gotk4_gtksource5_CompletionContext_ConnectProviderModelChanged), f)
}

// Activation gets the mode for which the context was activated.
//
// The function returns the following values:
//
func (self *CompletionContext) Activation() CompletionActivation {
	var _arg0 *C.GtkSourceCompletionContext   // out
	var _cret C.GtkSourceCompletionActivation // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_activation(_arg0)
	runtime.KeepAlive(self)

	var _completionActivation CompletionActivation // out

	_completionActivation = CompletionActivation(_cret)

	return _completionActivation
}

// Bounds gets the bounds for the completion, which is the beginning of the
// current word (taking break characters into account) to the current insertion
// cursor.
//
// If begin is non-NULL, it will be set to the start position of the current
// word being completed.
//
// If end is non-NULL, it will be set to the insertion cursor for the current
// word being completed.
//
// The function returns the following values:
//
//   - begin (optional): TextIter.
//   - end (optional): TextIter.
//   - ok: TRUE if the marks are still valid and begin or end was set.
//
func (self *CompletionContext) Bounds() (begin, end *gtk.TextIter, ok bool) {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _arg1 C.GtkTextIter                 // in
	var _arg2 C.GtkTextIter                 // in
	var _cret C.gboolean                    // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(self)

	var _begin *gtk.TextIter // out
	var _end *gtk.TextIter   // out
	var _ok bool             // out

	_begin = (*gtk.TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = (*gtk.TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _begin, _end, _ok
}

// Buffer gets the underlying buffer used by the context.
//
// This is a convenience function to get the buffer via the SourceCompletion
// property.
//
// The function returns the following values:
//
//   - buffer (optional) or NULL.
//
func (self *CompletionContext) Buffer() *Buffer {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _cret *C.GtkSourceBuffer            // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_buffer(_arg0)
	runtime.KeepAlive(self)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = wrapBuffer(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _buffer
}

// Busy gets the "busy" property. This is set to TRUE while the
// completion context is actively fetching proposals from registered
// SourceCompletionProvider's.
//
// The function returns the following values:
//
//   - ok: TRUE if the context is busy.
//
func (self *CompletionContext) Busy() bool {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _cret C.gboolean                    // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_busy(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Completion gets the SourceCompletion that created the context.
//
// The function returns the following values:
//
//   - completion (optional) or NULL.
//
func (self *CompletionContext) Completion() *Completion {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _cret *C.GtkSourceCompletion        // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_completion(_arg0)
	runtime.KeepAlive(self)

	var _completion *Completion // out

	if _cret != nil {
		_completion = wrapCompletion(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _completion
}

// Empty checks if any proposals have been provided to the context.
//
// Out of convenience, this function will return TRUE if self is NULL.
//
// The function returns the following values:
//
//   - ok: TRUE if there are no proposals in the context.
//
func (self *CompletionContext) Empty() bool {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _cret C.gboolean                    // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_empty(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Language gets the language of the underlying buffer, if any.
//
// The function returns the following values:
//
//   - language (optional) or NULL.
//
func (self *CompletionContext) Language() *Language {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _cret *C.GtkSourceLanguage          // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_language(_arg0)
	runtime.KeepAlive(self)

	var _language *Language // out

	if _cret != nil {
		_language = wrapLanguage(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _language
}

// ProposalsForProvider gets the Model associated with the provider.
//
// You can connect to SourceCompletionContext::model-changed to receive
// notifications about when the model has been replaced by a new model.
//
// The function takes the following parameters:
//
//   - provider: SourceCompletionProvider.
//
// The function returns the following values:
//
//   - listModel (optional) or NULL.
//
func (self *CompletionContext) ProposalsForProvider(provider CompletionProviderer) *gio.ListModel {
	var _arg0 *C.GtkSourceCompletionContext  // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _cret *C.GListModel                  // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gtk_source_completion_context_get_proposals_for_provider(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(provider)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// View gets the text view for the context.
//
// The function returns the following values:
//
//   - view (optional) or NULL.
//
func (self *CompletionContext) View() *View {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _cret *C.GtkSourceView              // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_view(_arg0)
	runtime.KeepAlive(self)

	var _view *View // out

	if _cret != nil {
		_view = wrapView(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _view
}

// Word gets the word that is being completed up to the position of the insert
// mark.
//
// The function returns the following values:
//
//   - utf8: string containing the current word.
//
func (self *CompletionContext) Word() string {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _cret *C.char                       // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_get_word(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ListProviders gets the providers that are associated with the context.
//
// The function returns the following values:
//
//   - listModel of SourceCompletionProvider.
//
func (self *CompletionContext) ListProviders() *gio.ListModel {
	var _arg0 *C.GtkSourceCompletionContext // out
	var _cret *C.GListModel                 // in

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_source_completion_context_list_providers(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// SetProposalsForProvider: this function allows providers to update their
// results for a context outside of a call to completionprovider.PopulateAsync.
//
// This can be used to immediately return results for a provider while it does
// additional asynchronous work. Doing so will allow the completions to update
// while the operation is in progress.
//
// The function takes the following parameters:
//
//   - provider: SourceCompletionProvider.
//   - results (optional) or NULL.
//
func (self *CompletionContext) SetProposalsForProvider(provider CompletionProviderer, results gio.ListModeller) {
	var _arg0 *C.GtkSourceCompletionContext  // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _arg2 *C.GListModel                  // out

	_arg0 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	if results != nil {
		_arg2 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(results).Native()))
	}

	C.gtk_source_completion_context_set_proposals_for_provider(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(results)
}

// CompletionContextClass: instance of this type is always passed by reference.
type CompletionContextClass struct {
	*completionContextClass
}

// completionContextClass is the struct that's finalized.
type completionContextClass struct {
	native *C.GtkSourceCompletionContextClass
}
