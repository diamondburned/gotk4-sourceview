// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
// extern gboolean _gotk4_gtksource5_IndenterInterface_is_trigger(GtkSourceIndenter*, GtkSourceView*, GtkTextIter*, GdkModifierType, guint);
import "C"

// glib.Type values for gtksourceindenter.go.
var GTypeIndenter = externglib.Type(C.gtk_source_indenter_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeIndenter, F: marshalIndenter},
	})
}

// IndenterOverrider contains methods that are overridable.
type IndenterOverrider interface {
	// IsTrigger: this function is used to determine if a key pressed should
	// cause the indenter to automatically indent.
	//
	// The default implementation of this virtual method will check to see if
	// keyval is GDK_KEY_Return or GDK_KEY_KP_Enter and state does not have
	// GDK_SHIFT_MASK set. This is to allow the user to avoid indentation when
	// Shift+Return is pressed. Other indenters may want to copy this behavior
	// to provide a consistent experience to users.
	//
	// The function takes the following parameters:
	//
	//    - view: SourceView.
	//    - location where ch is to be inserted.
	//    - state: modifier state for the insertion.
	//    - keyval pressed such as GDK_KEY_Return.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if indentation should be automatically triggered; otherwise
	//      FALSE and no indentation will be performed.
	//
	IsTrigger(view *View, location *gtk.TextIter, state gdk.ModifierType, keyval uint) bool
}

type Indenter struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*Indenter)(nil)
)

// Indenterer describes Indenter's interface methods.
type Indenterer interface {
	externglib.Objector

	// IsTrigger: this function is used to determine if a key pressed should
	// cause the indenter to automatically indent.
	IsTrigger(view *View, location *gtk.TextIter, state gdk.ModifierType, keyval uint) bool
}

var _ Indenterer = (*Indenter)(nil)

func ifaceInitIndenterer(gifacePtr, data C.gpointer) {
	iface := (*C.GtkSourceIndenterInterface)(unsafe.Pointer(gifacePtr))
	iface.is_trigger = (*[0]byte)(C._gotk4_gtksource5_IndenterInterface_is_trigger)
}

//export _gotk4_gtksource5_IndenterInterface_is_trigger
func _gotk4_gtksource5_IndenterInterface_is_trigger(arg0 *C.GtkSourceIndenter, arg1 *C.GtkSourceView, arg2 *C.GtkTextIter, arg3 C.GdkModifierType, arg4 C.guint) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(IndenterOverrider)

	var _view *View             // out
	var _location *gtk.TextIter // out
	var _state gdk.ModifierType // out
	var _keyval uint            // out

	_view = wrapView(externglib.Take(unsafe.Pointer(arg1)))
	_location = (*gtk.TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_state = gdk.ModifierType(arg3)
	_keyval = uint(arg4)

	ok := iface.IsTrigger(_view, _location, _state, _keyval)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapIndenter(obj *externglib.Object) *Indenter {
	return &Indenter{
		Object: obj,
	}
}

func marshalIndenter(p uintptr) (interface{}, error) {
	return wrapIndenter(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// IsTrigger: this function is used to determine if a key pressed should cause
// the indenter to automatically indent.
//
// The default implementation of this virtual method will check to see if keyval
// is GDK_KEY_Return or GDK_KEY_KP_Enter and state does not have GDK_SHIFT_MASK
// set. This is to allow the user to avoid indentation when Shift+Return is
// pressed. Other indenters may want to copy this behavior to provide a
// consistent experience to users.
//
// The function takes the following parameters:
//
//    - view: SourceView.
//    - location where ch is to be inserted.
//    - state: modifier state for the insertion.
//    - keyval pressed such as GDK_KEY_Return.
//
// The function returns the following values:
//
//    - ok: TRUE if indentation should be automatically triggered; otherwise
//      FALSE and no indentation will be performed.
//
func (self *Indenter) IsTrigger(view *View, location *gtk.TextIter, state gdk.ModifierType, keyval uint) bool {
	var _arg0 *C.GtkSourceIndenter // out
	var _arg1 *C.GtkSourceView     // out
	var _arg2 *C.GtkTextIter       // out
	var _arg3 C.GdkModifierType    // out
	var _arg4 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSourceIndenter)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.GtkSourceView)(unsafe.Pointer(externglib.InternObject(view).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(location)))
	_arg3 = C.GdkModifierType(state)
	_arg4 = C.guint(keyval)

	_cret = C.gtk_source_indenter_is_trigger(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(view)
	runtime.KeepAlive(location)
	runtime.KeepAlive(state)
	runtime.KeepAlive(keyval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
