// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_source_indenter_get_type()), F: marshalIndenterer},
	})
}

// IndenterOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type IndenterOverrider interface {
	// IsTrigger: this function is used to determine if a key pressed should
	// cause the indenter to automatically indent.
	//
	// The default implementation of this virtual method will check to see if
	// keyval is GDK_KEY_Return or GDK_KEY_KP_Enter and state does not have
	// GDK_SHIFT_MASK set. This is to allow the user to avoid indentation when
	// Shift+Return is pressed. Other indenters may want to copy this behavior
	// to provide a consistent experience to users.
	//
	// The function takes the following parameters:
	//
	//    - view: SourceView.
	//    - location where ch is to be inserted.
	//    - state: modifier state for the insertion.
	//    - keyval pressed such as GDK_KEY_Return.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if indentation should be automatically triggered; otherwise
	//      FALSE and no indentation will be performed.
	//
	IsTrigger(view *View, location *gtk.TextIter, state gdk.ModifierType, keyval uint) bool
}

type Indenter struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*Indenter)(nil)
)

// Indenterer describes Indenter's interface methods.
type Indenterer interface {
	externglib.Objector

	// IsTrigger: this function is used to determine if a key pressed should
	// cause the indenter to automatically indent.
	IsTrigger(view *View, location *gtk.TextIter, state gdk.ModifierType, keyval uint) bool
}

var _ Indenterer = (*Indenter)(nil)

func wrapIndenter(obj *externglib.Object) *Indenter {
	return &Indenter{
		Object: obj,
	}
}

func marshalIndenterer(p uintptr) (interface{}, error) {
	return wrapIndenter(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// IsTrigger: this function is used to determine if a key pressed should cause
// the indenter to automatically indent.
//
// The default implementation of this virtual method will check to see if keyval
// is GDK_KEY_Return or GDK_KEY_KP_Enter and state does not have GDK_SHIFT_MASK
// set. This is to allow the user to avoid indentation when Shift+Return is
// pressed. Other indenters may want to copy this behavior to provide a
// consistent experience to users.
//
// The function takes the following parameters:
//
//    - view: SourceView.
//    - location where ch is to be inserted.
//    - state: modifier state for the insertion.
//    - keyval pressed such as GDK_KEY_Return.
//
// The function returns the following values:
//
//    - ok: TRUE if indentation should be automatically triggered; otherwise
//      FALSE and no indentation will be performed.
//
func (self *Indenter) IsTrigger(view *View, location *gtk.TextIter, state gdk.ModifierType, keyval uint) bool {
	var _arg0 *C.GtkSourceIndenter // out
	var _arg1 *C.GtkSourceView     // out
	var _arg2 *C.GtkTextIter       // out
	var _arg3 C.GdkModifierType    // out
	var _arg4 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSourceIndenter)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkSourceView)(unsafe.Pointer(view.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(location)))
	_arg3 = C.GdkModifierType(state)
	_arg4 = C.guint(keyval)

	_cret = C.gtk_source_indenter_is_trigger(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(view)
	runtime.KeepAlive(location)
	runtime.KeepAlive(state)
	runtime.KeepAlive(keyval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
