// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_source_buffer_get_type()), F: marshalBufferer},
	})
}

// BufferOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type BufferOverrider interface {
	// The function takes the following parameters:
	//
	//    - iter
	//    - state
	//
	BracketMatched(iter *gtk.TextIter, state BracketMatchType)
	// Redo redoes the last undo operation. Use gtk_source_buffer_can_redo() to
	// check whether a call to this function will have any effect.
	//
	// This function emits the SourceBuffer::redo signal.
	Redo()
	// Undo undoes the last user action which modified the buffer. Use
	// gtk_source_buffer_can_undo() to check whether a call to this function
	// will have any effect.
	//
	// This function emits the SourceBuffer::undo signal.
	Undo()
}

type Buffer struct {
	_ [0]func() // equal guard
	gtk.TextBuffer
}

var (
	_ externglib.Objector = (*Buffer)(nil)
)

func wrapBuffer(obj *externglib.Object) *Buffer {
	return &Buffer{
		TextBuffer: gtk.TextBuffer{
			Object: obj,
		},
	}
}

func marshalBufferer(p uintptr) (interface{}, error) {
	return wrapBuffer(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectBracketMatched: iter is set to a valid iterator pointing to the
// matching bracket if state is GTK_SOURCE_BRACKET_MATCH_FOUND. Otherwise iter
// is meaningless.
//
// The signal is emitted only when the state changes, typically when the cursor
// moves.
//
// A use-case for this signal is to show messages in a Statusbar.
func (buffer *Buffer) ConnectBracketMatched(f func(iter *gtk.TextIter, state BracketMatchType)) externglib.SignalHandle {
	return buffer.Connect("bracket-matched", f)
}

// ConnectHighlightUpdated signal is emitted when the syntax highlighting and
// [context classes][context-classes] are updated in a certain region of the
// buffer.
func (buffer *Buffer) ConnectHighlightUpdated(f func(start, end *gtk.TextIter)) externglib.SignalHandle {
	return buffer.Connect("highlight-updated", f)
}

// ConnectRedo signal is emitted to redo the last undo operation.
func (buffer *Buffer) ConnectRedo(f func()) externglib.SignalHandle {
	return buffer.Connect("redo", f)
}

// ConnectSourceMarkUpdated signal is emitted each time a mark is added to,
// moved or removed from the buffer.
func (buffer *Buffer) ConnectSourceMarkUpdated(f func(mark gtk.TextMark)) externglib.SignalHandle {
	return buffer.Connect("source-mark-updated", f)
}

// ConnectUndo signal is emitted to undo the last user action which modified the
// buffer.
func (buffer *Buffer) ConnectUndo(f func()) externglib.SignalHandle {
	return buffer.Connect("undo", f)
}

// NewBuffer creates a new source buffer.
//
// The function takes the following parameters:
//
//    - table (optional) or NULL to create a new one.
//
// The function returns the following values:
//
//    - buffer: new source buffer.
//
func NewBuffer(table *gtk.TextTagTable) *Buffer {
	var _arg1 *C.GtkTextTagTable // out
	var _cret *C.GtkSourceBuffer // in

	if table != nil {
		_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))
	}

	_cret = C.gtk_source_buffer_new(_arg1)
	runtime.KeepAlive(table)

	var _buffer *Buffer // out

	_buffer = wrapBuffer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _buffer
}

// NewBufferWithLanguage creates a new source buffer using the highlighting
// patterns in language. This is equivalent to creating a new source buffer with
// a new tag table and then calling gtk_source_buffer_set_language().
//
// The function takes the following parameters:
//
//    - language: SourceLanguage.
//
// The function returns the following values:
//
//    - buffer: new source buffer which will highlight text according to the
//      highlighting patterns in language.
//
func NewBufferWithLanguage(language *Language) *Buffer {
	var _arg1 *C.GtkSourceLanguage // out
	var _cret *C.GtkSourceBuffer   // in

	_arg1 = (*C.GtkSourceLanguage)(unsafe.Pointer(language.Native()))

	_cret = C.gtk_source_buffer_new_with_language(_arg1)
	runtime.KeepAlive(language)

	var _buffer *Buffer // out

	_buffer = wrapBuffer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _buffer
}

// BackwardIterToSourceMark moves iter to the position of the previous
// SourceMark of the given category. Returns TRUE if iter was moved. If category
// is NULL, the previous source mark can be of any category.
//
// The function takes the following parameters:
//
//    - iter: iterator.
//    - category (optional) to search for, or NULL.
//
// The function returns the following values:
//
//    - ok: whether iter was moved.
//
func (buffer *Buffer) BackwardIterToSourceMark(iter *gtk.TextIter, category string) bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if category != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_source_buffer_backward_iter_to_source_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(category)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BeginNotUndoableAction marks the beginning of a not undoable action on the
// buffer, disabling the undo manager. Typically you would call this function
// before initially setting the contents of the buffer (e.g. when loading a file
// in a text editor).
//
// You may nest gtk_source_buffer_begin_not_undoable_action() /
// gtk_source_buffer_end_not_undoable_action() blocks.
func (buffer *Buffer) BeginNotUndoableAction() {
	var _arg0 *C.GtkSourceBuffer // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_source_buffer_begin_not_undoable_action(_arg0)
	runtime.KeepAlive(buffer)
}

// CanRedo determines whether a source buffer can redo the last action (i.e. if
// the last operation was an undo).
//
// The function returns the following values:
//
//    - ok: TRUE if a redo is possible.
//
func (buffer *Buffer) CanRedo() bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_can_redo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanUndo determines whether a source buffer can undo the last action.
//
// The function returns the following values:
//
//    - ok: TRUE if it's possible to undo the last action.
//
func (buffer *Buffer) CanUndo() bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_can_undo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChangeCase changes the case of the text between the specified iterators.
//
// The function takes the following parameters:
//
//    - caseType: how to change the case.
//    - start: TextIter.
//    - end: TextIter.
//
func (buffer *Buffer) ChangeCase(caseType ChangeCaseType, start, end *gtk.TextIter) {
	var _arg0 *C.GtkSourceBuffer        // out
	var _arg1 C.GtkSourceChangeCaseType // out
	var _arg2 *C.GtkTextIter            // out
	var _arg3 *C.GtkTextIter            // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = C.GtkSourceChangeCaseType(caseType)
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_source_buffer_change_case(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(caseType)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// CreateSourceMark creates a source mark in the buffer of category category. A
// source mark is a TextMark but organised into categories. Depending on the
// category a pixbuf can be specified that will be displayed along the line of
// the mark.
//
// Like a TextMark, a SourceMark can be anonymous if the passed name is NULL.
// Also, the buffer owns the marks so you shouldn't unreference it.
//
// Marks always have left gravity and are moved to the beginning of the line
// when the user deletes the line they were in.
//
// Typical uses for a source mark are bookmarks, breakpoints, current executing
// instruction indication in a source file, etc..
//
// The function takes the following parameters:
//
//    - name (optional) of the mark, or NULL.
//    - category: string defining the mark category.
//    - where: location to place the mark.
//
// The function returns the following values:
//
//    - mark: new SourceMark, owned by the buffer.
//
func (buffer *Buffer) CreateSourceMark(name, category string, where *gtk.TextIter) *Mark {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.GtkTextIter     // out
	var _cret *C.GtkSourceMark   // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	_cret = C.gtk_source_buffer_create_source_mark(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(category)
	runtime.KeepAlive(where)

	var _mark *Mark // out

	_mark = wrapMark(externglib.Take(unsafe.Pointer(_cret)))

	return _mark
}

// EndNotUndoableAction marks the end of a not undoable action on the buffer.
// When the last not undoable block is closed through the call to this function,
// the list of undo actions is cleared and the undo manager is re-enabled.
func (buffer *Buffer) EndNotUndoableAction() {
	var _arg0 *C.GtkSourceBuffer // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_source_buffer_end_not_undoable_action(_arg0)
	runtime.KeepAlive(buffer)
}

// EnsureHighlight forces buffer to analyze and highlight the given area
// synchronously.
//
// <note> <para> This is a potentially slow operation and should be used only
// when you need to make sure that some text not currently visible is
// highlighted, for instance before printing. </para> </note>.
//
// The function takes the following parameters:
//
//    - start of the area to highlight.
//    - end of the area to highlight.
//
func (buffer *Buffer) EnsureHighlight(start, end *gtk.TextIter) {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.GtkTextIter     // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_source_buffer_ensure_highlight(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ForwardIterToSourceMark moves iter to the position of the next SourceMark of
// the given category. Returns TRUE if iter was moved. If category is NULL, the
// next source mark can be of any category.
//
// The function takes the following parameters:
//
//    - iter: iterator.
//    - category (optional) to search for, or NULL.
//
// The function returns the following values:
//
//    - ok: whether iter was moved.
//
func (buffer *Buffer) ForwardIterToSourceMark(iter *gtk.TextIter, category string) bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if category != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_source_buffer_forward_iter_to_source_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(category)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContextClassesAtIter: get all defined context classes at iter.
//
// See the SourceBuffer description for the list of default context classes.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//
// The function returns the following values:
//
//    - utf8s: new NULL terminated array of context class names. Use g_strfreev()
//      to free the array if it is no longer needed.
//
func (buffer *Buffer) ContextClassesAtIter(iter *gtk.TextIter) []string {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _cret **C.gchar          // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_source_buffer_get_context_classes_at_iter(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// HighlightMatchingBrackets determines whether bracket match highlighting is
// activated for the source buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the source buffer will highlight matching brackets.
//
func (buffer *Buffer) HighlightMatchingBrackets() bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_get_highlight_matching_brackets(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HighlightSyntax determines whether syntax highlighting is activated in the
// source buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if syntax highlighting is enabled, FALSE otherwise.
//
func (buffer *Buffer) HighlightSyntax() bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_get_highlight_syntax(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//    - ok: whether the buffer has an implicit trailing newline.
//
func (buffer *Buffer) ImplicitTrailingNewline() bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_get_implicit_trailing_newline(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Language returns the SourceLanguage associated with the buffer, see
// gtk_source_buffer_set_language(). The returned object should not be
// unreferenced by the user.
//
// The function returns the following values:
//
//    - language (optional) associated with the buffer, or NULL.
//
func (buffer *Buffer) Language() *Language {
	var _arg0 *C.GtkSourceBuffer   // out
	var _cret *C.GtkSourceLanguage // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_get_language(_arg0)
	runtime.KeepAlive(buffer)

	var _language *Language // out

	if _cret != nil {
		_language = wrapLanguage(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _language
}

// MaxUndoLevels determines the number of undo levels the buffer will track for
// buffer edits.
//
// The function returns the following values:
//
//    - gint: maximum number of possible undo levels or -1 if no limit is set.
//
func (buffer *Buffer) MaxUndoLevels() int {
	var _arg0 *C.GtkSourceBuffer // out
	var _cret C.gint             // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_get_max_undo_levels(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SourceMarksAtIter returns the list of marks of the given category at iter. If
// category is NULL it returns all marks at iter.
//
// The function takes the following parameters:
//
//    - iter: iterator.
//    - category (optional) to search for, or NULL.
//
// The function returns the following values:
//
//    - sList: a newly allocated List.
//
func (buffer *Buffer) SourceMarksAtIter(iter *gtk.TextIter, category string) []Mark {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.gchar           // out
	var _cret *C.GSList          // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if category != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_source_buffer_get_source_marks_at_iter(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(category)

	var _sList []Mark // out

	_sList = make([]Mark, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkSourceMark)(v)
		var dst Mark // out
		dst = *wrapMark(externglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// SourceMarksAtLine returns the list of marks of the given category at line. If
// category is NULL, all marks at line are returned.
//
// The function takes the following parameters:
//
//    - line number.
//    - category (optional) to search for, or NULL.
//
// The function returns the following values:
//
//    - sList: a newly allocated List.
//
func (buffer *Buffer) SourceMarksAtLine(line int, category string) []Mark {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 C.gint             // out
	var _arg2 *C.gchar           // out
	var _cret *C.GSList          // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = C.gint(line)
	if category != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_source_buffer_get_source_marks_at_line(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(line)
	runtime.KeepAlive(category)

	var _sList []Mark // out

	_sList = make([]Mark, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkSourceMark)(v)
		var dst Mark // out
		dst = *wrapMark(externglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// StyleScheme returns the SourceStyleScheme associated with the buffer, see
// gtk_source_buffer_set_style_scheme(). The returned object should not be
// unreferenced by the user.
//
// The function returns the following values:
//
//    - styleScheme (optional) with the buffer, or NULL.
//
func (buffer *Buffer) StyleScheme() *StyleScheme {
	var _arg0 *C.GtkSourceBuffer      // out
	var _cret *C.GtkSourceStyleScheme // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_get_style_scheme(_arg0)
	runtime.KeepAlive(buffer)

	var _styleScheme *StyleScheme // out

	if _cret != nil {
		_styleScheme = wrapStyleScheme(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _styleScheme
}

// UndoManager returns the SourceUndoManager associated with the buffer, see
// gtk_source_buffer_set_undo_manager(). The returned object should not be
// unreferenced by the user.
//
// The function returns the following values:
//
//    - undoManager (optional) associated with the buffer, or NULL.
//
func (buffer *Buffer) UndoManager() UndoManagerer {
	var _arg0 *C.GtkSourceBuffer      // out
	var _cret *C.GtkSourceUndoManager // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_source_buffer_get_undo_manager(_arg0)
	runtime.KeepAlive(buffer)

	var _undoManager UndoManagerer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(UndoManagerer)
				return ok
			})
			rv, ok := casted.(UndoManagerer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtksource.UndoManagerer")
			}
			_undoManager = rv
		}
	}

	return _undoManager
}

// IterBackwardToContextClassToggle moves backward to the next toggle (on or
// off) of the context class. If no matching context class toggles are found,
// returns FALSE, otherwise TRUE. Does not return toggles located at iter, only
// toggles after iter. Sets iter to the location of the toggle, or to the end of
// the buffer if no toggle is found.
//
// See the SourceBuffer description for the list of default context classes.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//    - contextClass: context class.
//
// The function returns the following values:
//
//    - ok: whether we found a context class toggle before iter.
//
func (buffer *Buffer) IterBackwardToContextClassToggle(iter *gtk.TextIter, contextClass string) bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(contextClass)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_source_buffer_iter_backward_to_context_class_toggle(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(contextClass)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterForwardToContextClassToggle moves forward to the next toggle (on or off)
// of the context class. If no matching context class toggles are found, returns
// FALSE, otherwise TRUE. Does not return toggles located at iter, only toggles
// after iter. Sets iter to the location of the toggle, or to the end of the
// buffer if no toggle is found.
//
// See the SourceBuffer description for the list of default context classes.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//    - contextClass: context class.
//
// The function returns the following values:
//
//    - ok: whether we found a context class toggle after iter.
//
func (buffer *Buffer) IterForwardToContextClassToggle(iter *gtk.TextIter, contextClass string) bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(contextClass)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_source_buffer_iter_forward_to_context_class_toggle(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(contextClass)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterHasContextClass: check if the class context_class is set on iter.
//
// See the SourceBuffer description for the list of default context classes.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//    - contextClass class to search for.
//
// The function returns the following values:
//
//    - ok: whether iter has the context class.
//
func (buffer *Buffer) IterHasContextClass(iter *gtk.TextIter, contextClass string) bool {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(contextClass)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_source_buffer_iter_has_context_class(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(contextClass)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// JoinLines joins the lines of text between the specified iterators.
//
// The function takes the following parameters:
//
//    - start: TextIter.
//    - end: TextIter.
//
func (buffer *Buffer) JoinLines(start, end *gtk.TextIter) {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.GtkTextIter     // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_source_buffer_join_lines(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Redo redoes the last undo operation. Use gtk_source_buffer_can_redo() to
// check whether a call to this function will have any effect.
//
// This function emits the SourceBuffer::redo signal.
func (buffer *Buffer) Redo() {
	var _arg0 *C.GtkSourceBuffer // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_source_buffer_redo(_arg0)
	runtime.KeepAlive(buffer)
}

// RemoveSourceMarks: remove all marks of category between start and end from
// the buffer. If category is NULL, all marks in the range will be removed.
//
// The function takes the following parameters:
//
//    - start: TextIter.
//    - end: TextIter.
//    - category (optional) to search for, or NULL.
//
func (buffer *Buffer) RemoveSourceMarks(start, end *gtk.TextIter, category string) {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 *C.GtkTextIter     // out
	var _arg2 *C.GtkTextIter     // out
	var _arg3 *C.gchar           // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if category != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.gtk_source_buffer_remove_source_marks(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(category)
}

// SetHighlightMatchingBrackets controls the bracket match highlighting function
// in the buffer. If activated, when you position your cursor over a bracket
// character (a parenthesis, a square bracket, etc.) the matching opening or
// closing bracket character will be highlighted.
//
// The function takes the following parameters:
//
//    - highlight: TRUE if you want matching brackets highlighted.
//
func (buffer *Buffer) SetHighlightMatchingBrackets(highlight bool) {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	if highlight {
		_arg1 = C.TRUE
	}

	C.gtk_source_buffer_set_highlight_matching_brackets(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(highlight)
}

// SetHighlightSyntax controls whether syntax is highlighted in the buffer.
//
// If highlight is TRUE, the text will be highlighted according to the syntax
// patterns specified in the SourceLanguage set with
// gtk_source_buffer_set_language().
//
// If highlight is FALSE, syntax highlighting is disabled and all the TextTag
// objects that have been added by the syntax highlighting engine are removed
// from the buffer.
//
// The function takes the following parameters:
//
//    - highlight: TRUE to enable syntax highlighting, FALSE to disable it.
//
func (buffer *Buffer) SetHighlightSyntax(highlight bool) {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	if highlight {
		_arg1 = C.TRUE
	}

	C.gtk_source_buffer_set_highlight_syntax(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(highlight)
}

// SetImplicitTrailingNewline sets whether the buffer has an implicit trailing
// newline.
//
// If an explicit trailing newline is present in a TextBuffer, TextView shows it
// as an empty line. This is generally not what the user expects.
//
// If implicit_trailing_newline is TRUE (the default value): - when a
// SourceFileLoader loads the content of a file into the buffer, the trailing
// newline (if present in the file) is not inserted into the buffer. - when a
// SourceFileSaver saves the content of the buffer into a file, a trailing
// newline is added to the file.
//
// On the other hand, if implicit_trailing_newline is FALSE, the file's content
// is not modified when loaded into the buffer, and the buffer's content is not
// modified when saved into a file.
//
// The function takes the following parameters:
//
//    - implicitTrailingNewline: new value.
//
func (buffer *Buffer) SetImplicitTrailingNewline(implicitTrailingNewline bool) {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	if implicitTrailingNewline {
		_arg1 = C.TRUE
	}

	C.gtk_source_buffer_set_implicit_trailing_newline(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(implicitTrailingNewline)
}

// SetLanguage associates a SourceLanguage with the buffer.
//
// Note that a SourceLanguage affects not only the syntax highlighting, but also
// the [context classes][context-classes]. If you want to disable just the
// syntax highlighting, see gtk_source_buffer_set_highlight_syntax().
//
// The buffer holds a reference to language.
//
// The function takes the following parameters:
//
//    - language (optional) to set, or NULL.
//
func (buffer *Buffer) SetLanguage(language *Language) {
	var _arg0 *C.GtkSourceBuffer   // out
	var _arg1 *C.GtkSourceLanguage // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	if language != nil {
		_arg1 = (*C.GtkSourceLanguage)(unsafe.Pointer(language.Native()))
	}

	C.gtk_source_buffer_set_language(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(language)
}

// SetMaxUndoLevels sets the number of undo levels for user actions the buffer
// will track. If the number of user actions exceeds the limit set by this
// function, older actions will be discarded.
//
// If max_undo_levels is -1, the undo/redo is unlimited.
//
// If max_undo_levels is 0, the undo/redo is disabled.
//
// The function takes the following parameters:
//
//    - maxUndoLevels: desired maximum number of undo levels.
//
func (buffer *Buffer) SetMaxUndoLevels(maxUndoLevels int) {
	var _arg0 *C.GtkSourceBuffer // out
	var _arg1 C.gint             // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = C.gint(maxUndoLevels)

	C.gtk_source_buffer_set_max_undo_levels(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(maxUndoLevels)
}

// SetStyleScheme sets a SourceStyleScheme to be used by the buffer and the
// view.
//
// Note that a SourceStyleScheme affects not only the syntax highlighting, but
// also other SourceView features such as highlighting the current line,
// matching brackets, the line numbers, etc.
//
// Instead of setting a NULL scheme, it is better to disable syntax highlighting
// with gtk_source_buffer_set_highlight_syntax(), and setting the
// SourceStyleScheme with the "classic" or "tango" ID, because those two style
// schemes follow more closely the GTK+ theme (for example for the background
// color).
//
// The buffer holds a reference to scheme.
//
// The function takes the following parameters:
//
//    - scheme (optional) or NULL.
//
func (buffer *Buffer) SetStyleScheme(scheme *StyleScheme) {
	var _arg0 *C.GtkSourceBuffer      // out
	var _arg1 *C.GtkSourceStyleScheme // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	if scheme != nil {
		_arg1 = (*C.GtkSourceStyleScheme)(unsafe.Pointer(scheme.Native()))
	}

	C.gtk_source_buffer_set_style_scheme(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(scheme)
}

// SetUndoManager: set the buffer undo manager. If manager is NULL the default
// undo manager will be set.
//
// The function takes the following parameters:
//
//    - manager (optional) or NULL.
//
func (buffer *Buffer) SetUndoManager(manager UndoManagerer) {
	var _arg0 *C.GtkSourceBuffer      // out
	var _arg1 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	if manager != nil {
		_arg1 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))
	}

	C.gtk_source_buffer_set_undo_manager(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(manager)
}

// SortLines: sort the lines of text between the specified iterators.
//
// The function takes the following parameters:
//
//    - start: TextIter.
//    - end: TextIter.
//    - flags specifying how the sort should behave.
//    - column: sort considering the text starting at the given column.
//
func (buffer *Buffer) SortLines(start, end *gtk.TextIter, flags SortFlags, column int) {
	var _arg0 *C.GtkSourceBuffer   // out
	var _arg1 *C.GtkTextIter       // out
	var _arg2 *C.GtkTextIter       // out
	var _arg3 C.GtkSourceSortFlags // out
	var _arg4 C.gint               // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	_arg3 = C.GtkSourceSortFlags(flags)
	_arg4 = C.gint(column)

	C.gtk_source_buffer_sort_lines(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(column)
}

// Undo undoes the last user action which modified the buffer. Use
// gtk_source_buffer_can_undo() to check whether a call to this function will
// have any effect.
//
// This function emits the SourceBuffer::undo signal.
func (buffer *Buffer) Undo() {
	var _arg0 *C.GtkSourceBuffer // out

	_arg0 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_source_buffer_undo(_arg0)
	runtime.KeepAlive(buffer)
}
