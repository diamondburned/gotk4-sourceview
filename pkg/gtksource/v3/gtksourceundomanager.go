// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_source_undo_manager_get_type()), F: marshalUndoManagerer},
	})
}

// UndoManagerOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type UndoManagerOverrider interface {
	// BeginNotUndoableAction: begin a not undoable action on the buffer. All
	// changes between this call and the call to
	// gtk_source_undo_manager_end_not_undoable_action() cannot be undone. This
	// function should be re-entrant.
	BeginNotUndoableAction()
	// CanRedo: get whether there are redo operations available.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if there are redo operations available, FALSE otherwise.
	//
	CanRedo() bool
	// CanRedoChanged emits the SourceUndoManager::can-redo-changed signal.
	CanRedoChanged()
	// CanUndo: get whether there are undo operations available.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if there are undo operations available, FALSE otherwise.
	//
	CanUndo() bool
	// CanUndoChanged emits the SourceUndoManager::can-undo-changed signal.
	CanUndoChanged()
	// EndNotUndoableAction ends a not undoable action on the buffer.
	EndNotUndoableAction()
	// Redo: perform a single redo. Calling this function when there are no redo
	// operations available is an error. Use gtk_source_undo_manager_can_redo()
	// to find out if there are redo operations available.
	Redo()
	// Undo: perform a single undo. Calling this function when there are no undo
	// operations available is an error. Use gtk_source_undo_manager_can_undo()
	// to find out if there are undo operations available.
	Undo()
}

type UndoManager struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*UndoManager)(nil)
)

// UndoManagerer describes UndoManager's interface methods.
type UndoManagerer interface {
	externglib.Objector

	// BeginNotUndoableAction: begin a not undoable action on the buffer.
	BeginNotUndoableAction()
	// CanRedo: get whether there are redo operations available.
	CanRedo() bool
	// CanRedoChanged emits the SourceUndoManager::can-redo-changed signal.
	CanRedoChanged()
	// CanUndo: get whether there are undo operations available.
	CanUndo() bool
	// CanUndoChanged emits the SourceUndoManager::can-undo-changed signal.
	CanUndoChanged()
	// EndNotUndoableAction ends a not undoable action on the buffer.
	EndNotUndoableAction()
	// Redo: perform a single redo.
	Redo()
	// Undo: perform a single undo.
	Undo()
}

var _ UndoManagerer = (*UndoManager)(nil)

func wrapUndoManager(obj *externglib.Object) *UndoManager {
	return &UndoManager{
		Object: obj,
	}
}

func marshalUndoManagerer(p uintptr) (interface{}, error) {
	return wrapUndoManager(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCanRedoChanged: emitted when the ability to redo has changed.
func (manager *UndoManager) ConnectCanRedoChanged(f func()) externglib.SignalHandle {
	return manager.Connect("can-redo-changed", f)
}

// ConnectCanUndoChanged: emitted when the ability to undo has changed.
func (manager *UndoManager) ConnectCanUndoChanged(f func()) externglib.SignalHandle {
	return manager.Connect("can-undo-changed", f)
}

// BeginNotUndoableAction: begin a not undoable action on the buffer. All
// changes between this call and the call to
// gtk_source_undo_manager_end_not_undoable_action() cannot be undone. This
// function should be re-entrant.
func (manager *UndoManager) BeginNotUndoableAction() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))

	C.gtk_source_undo_manager_begin_not_undoable_action(_arg0)
	runtime.KeepAlive(manager)
}

// CanRedo: get whether there are redo operations available.
//
// The function returns the following values:
//
//    - ok: TRUE if there are redo operations available, FALSE otherwise.
//
func (manager *UndoManager) CanRedo() bool {
	var _arg0 *C.GtkSourceUndoManager // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))

	_cret = C.gtk_source_undo_manager_can_redo(_arg0)
	runtime.KeepAlive(manager)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanRedoChanged emits the SourceUndoManager::can-redo-changed signal.
func (manager *UndoManager) CanRedoChanged() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))

	C.gtk_source_undo_manager_can_redo_changed(_arg0)
	runtime.KeepAlive(manager)
}

// CanUndo: get whether there are undo operations available.
//
// The function returns the following values:
//
//    - ok: TRUE if there are undo operations available, FALSE otherwise.
//
func (manager *UndoManager) CanUndo() bool {
	var _arg0 *C.GtkSourceUndoManager // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))

	_cret = C.gtk_source_undo_manager_can_undo(_arg0)
	runtime.KeepAlive(manager)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanUndoChanged emits the SourceUndoManager::can-undo-changed signal.
func (manager *UndoManager) CanUndoChanged() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))

	C.gtk_source_undo_manager_can_undo_changed(_arg0)
	runtime.KeepAlive(manager)
}

// EndNotUndoableAction ends a not undoable action on the buffer.
func (manager *UndoManager) EndNotUndoableAction() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))

	C.gtk_source_undo_manager_end_not_undoable_action(_arg0)
	runtime.KeepAlive(manager)
}

// Redo: perform a single redo. Calling this function when there are no redo
// operations available is an error. Use gtk_source_undo_manager_can_redo() to
// find out if there are redo operations available.
func (manager *UndoManager) Redo() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))

	C.gtk_source_undo_manager_redo(_arg0)
	runtime.KeepAlive(manager)
}

// Undo: perform a single undo. Calling this function when there are no undo
// operations available is an error. Use gtk_source_undo_manager_can_undo() to
// find out if there are undo operations available.
func (manager *UndoManager) Undo() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(manager.Native()))

	C.gtk_source_undo_manager_undo(_arg0)
	runtime.KeepAlive(manager)
}
