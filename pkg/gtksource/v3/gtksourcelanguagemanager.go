// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_source_language_manager_get_type()), F: marshalLanguageManagerer},
	})
}

type LanguageManager struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*LanguageManager)(nil)
)

func wrapLanguageManager(obj *externglib.Object) *LanguageManager {
	return &LanguageManager{
		Object: obj,
	}
}

func marshalLanguageManagerer(p uintptr) (interface{}, error) {
	return wrapLanguageManager(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewLanguageManager creates a new language manager. If you do not need more
// than one language manager or a private language manager instance then use
// gtk_source_language_manager_get_default() instead.
//
// The function returns the following values:
//
//    - languageManager: new SourceLanguageManager.
//
func NewLanguageManager() *LanguageManager {
	var _cret *C.GtkSourceLanguageManager // in

	_cret = C.gtk_source_language_manager_new()

	var _languageManager *LanguageManager // out

	_languageManager = wrapLanguageManager(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _languageManager
}

// Language gets the SourceLanguage identified by the given id in the language
// manager.
//
// The function takes the following parameters:
//
//    - id: language id.
//
// The function returns the following values:
//
//    - language (optional) or NULL if there is no language identified by the
//      given id. Return value is owned by lm and should not be freed.
//
func (lm *LanguageManager) Language(id string) *Language {
	var _arg0 *C.GtkSourceLanguageManager // out
	var _arg1 *C.gchar                    // out
	var _cret *C.GtkSourceLanguage        // in

	_arg0 = (*C.GtkSourceLanguageManager)(unsafe.Pointer(lm.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_source_language_manager_get_language(_arg0, _arg1)
	runtime.KeepAlive(lm)
	runtime.KeepAlive(id)

	var _language *Language // out

	if _cret != nil {
		_language = wrapLanguage(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _language
}

// LanguageIDs returns the ids of the available languages.
//
// The function returns the following values:
//
//    - utf8s (optional): a NULL-terminated array of strings containing the ids
//      of the available languages or NULL if no language is available. The array
//      is sorted alphabetically according to the language name. The array is
//      owned by lm and must not be modified.
//
func (lm *LanguageManager) LanguageIDs() []string {
	var _arg0 *C.GtkSourceLanguageManager // out
	var _cret **C.gchar                   // in

	_arg0 = (*C.GtkSourceLanguageManager)(unsafe.Pointer(lm.Native()))

	_cret = C.gtk_source_language_manager_get_language_ids(_arg0)
	runtime.KeepAlive(lm)

	var _utf8s []string // out

	if _cret != nil {
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			}
		}
	}

	return _utf8s
}

// SearchPath gets the list directories where lm looks for language files.
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated array containg a list of language files
//      directories. The array is owned by lm and must not be modified.
//
func (lm *LanguageManager) SearchPath() []string {
	var _arg0 *C.GtkSourceLanguageManager // out
	var _cret **C.gchar                   // in

	_arg0 = (*C.GtkSourceLanguageManager)(unsafe.Pointer(lm.Native()))

	_cret = C.gtk_source_language_manager_get_search_path(_arg0)
	runtime.KeepAlive(lm)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// GuessLanguage picks a SourceLanguage for given file name and content type,
// according to the information in lang files. Either filename or content_type
// may be NULL. This function can be used as follows:
//
// <informalexample><programlisting> GtkSourceLanguage *lang; lang =
// gtk_source_language_manager_guess_language (filename, NULL);
// gtk_source_buffer_set_language (buffer, lang);
// </programlisting></informalexample>
//
// or
//
// <informalexample><programlisting> GtkSourceLanguage *lang = NULL; gboolean
// result_uncertain; gchar *content_type;
//
//    content_type = g_content_type_guess (filename, NULL, 0, &result_uncertain);
//    if (result_uncertain)
//      {
//        g_free (content_type);
//        content_type = NULL;
//      }
//
//    lang = gtk_source_language_manager_guess_language (manager, filename, content_type);
//    gtk_source_buffer_set_language (buffer, lang);
//
//    g_free (content_type);
//
// </programlisting></informalexample>
//
// etc. Use gtk_source_language_get_mime_types() and
// gtk_source_language_get_globs() if you need full control over file ->
// language mapping.
//
// The function takes the following parameters:
//
//    - filename (optional) in Glib filename encoding, or NULL.
//    - contentType (optional): content type (as in GIO API), or NULL.
//
// The function returns the following values:
//
//    - language (optional) or NULL if there is no suitable language for given
//      filename and/or content_type. Return value is owned by lm and should not
//      be freed.
//
func (lm *LanguageManager) GuessLanguage(filename, contentType string) *Language {
	var _arg0 *C.GtkSourceLanguageManager // out
	var _arg1 *C.gchar                    // out
	var _arg2 *C.gchar                    // out
	var _cret *C.GtkSourceLanguage        // in

	_arg0 = (*C.GtkSourceLanguageManager)(unsafe.Pointer(lm.Native()))
	if filename != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if contentType != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_source_language_manager_guess_language(_arg0, _arg1, _arg2)
	runtime.KeepAlive(lm)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(contentType)

	var _language *Language // out

	if _cret != nil {
		_language = wrapLanguage(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _language
}

// SetSearchPath sets the list of directories where the lm looks for language
// files. If dirs is NULL, the search path is reset to default.
//
// <note> <para> At the moment this function can be called only before the
// language files are loaded for the first time. In practice to set a custom
// search path for a SourceLanguageManager, you have to call this function right
// after creating it. </para> </note>.
//
// The function takes the following parameters:
//
//    - dirs (optional): a NULL-terminated array of strings or NULL.
//
func (lm *LanguageManager) SetSearchPath(dirs []string) {
	var _arg0 *C.GtkSourceLanguageManager // out
	var _arg1 **C.gchar                   // out

	_arg0 = (*C.GtkSourceLanguageManager)(unsafe.Pointer(lm.Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(dirs) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(dirs)+1)
			var zero *C.gchar
			out[len(dirs)] = zero
			for i := range dirs {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(dirs[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_source_language_manager_set_search_path(_arg0, _arg1)
	runtime.KeepAlive(lm)
	runtime.KeepAlive(dirs)
}

// LanguageManagerGetDefault returns the default SourceLanguageManager instance.
//
// The function returns the following values:
//
//    - languageManager value is owned by GtkSourceView library and must not be
//      unref'ed.
//
func LanguageManagerGetDefault() *LanguageManager {
	var _cret *C.GtkSourceLanguageManager // in

	_cret = C.gtk_source_language_manager_get_default()

	var _languageManager *LanguageManager // out

	_languageManager = wrapLanguageManager(externglib.Take(unsafe.Pointer(_cret)))

	return _languageManager
}
