// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
// extern void _gotk4_gtksource4_GutterRenderer_ConnectQueueDraw(gpointer, guintptr);
// extern void _gotk4_gtksource4_GutterRenderer_ConnectQueryData(gpointer, GtkTextIter*, GtkTextIter*, GtkSourceGutterRendererState, guintptr);
// extern void _gotk4_gtksource4_GutterRenderer_ConnectActivate(gpointer, GtkTextIter*, GdkRectangle*, GdkEvent, guintptr);
// extern void _gotk4_gtksource4_GutterRendererClass_queue_draw(GtkSourceGutterRenderer*);
// extern void _gotk4_gtksource4_GutterRendererClass_query_data(GtkSourceGutterRenderer*, GtkTextIter*, GtkTextIter*, GtkSourceGutterRendererState);
// extern void _gotk4_gtksource4_GutterRendererClass_end(GtkSourceGutterRenderer*);
// extern void _gotk4_gtksource4_GutterRendererClass_draw(GtkSourceGutterRenderer*, cairo_t*, GdkRectangle*, GdkRectangle*, GtkTextIter*, GtkTextIter*, GtkSourceGutterRendererState);
// extern void _gotk4_gtksource4_GutterRendererClass_change_view(GtkSourceGutterRenderer*, GtkTextView*);
// extern void _gotk4_gtksource4_GutterRendererClass_change_buffer(GtkSourceGutterRenderer*, GtkTextBuffer*);
// extern void _gotk4_gtksource4_GutterRendererClass_begin(GtkSourceGutterRenderer*, cairo_t*, GdkRectangle*, GdkRectangle*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtksource4_GutterRendererClass_activate(GtkSourceGutterRenderer*, GtkTextIter*, GdkRectangle*, GdkEvent*);
// extern gboolean _gotk4_gtksource4_GutterRenderer_ConnectQueryTooltip(gpointer, GtkTextIter*, GdkRectangle*, gint, gint, GtkTooltip*, guintptr);
// extern gboolean _gotk4_gtksource4_GutterRenderer_ConnectQueryActivatable(gpointer, GtkTextIter*, GdkRectangle*, GdkEvent, guintptr);
// extern gboolean _gotk4_gtksource4_GutterRendererClass_query_tooltip(GtkSourceGutterRenderer*, GtkTextIter*, GdkRectangle*, gint, gint, GtkTooltip*);
// extern gboolean _gotk4_gtksource4_GutterRendererClass_query_activatable(GtkSourceGutterRenderer*, GtkTextIter*, GdkRectangle*, GdkEvent*);
// gboolean _gotk4_gtksource4_GutterRenderer_virtual_query_activatable(void* fnptr, GtkSourceGutterRenderer* arg0, GtkTextIter* arg1, GdkRectangle* arg2, GdkEvent* arg3) {
//   return ((gboolean (*)(GtkSourceGutterRenderer*, GtkTextIter*, GdkRectangle*, GdkEvent*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gtksource4_GutterRenderer_virtual_query_tooltip(void* fnptr, GtkSourceGutterRenderer* arg0, GtkTextIter* arg1, GdkRectangle* arg2, gint arg3, gint arg4, GtkTooltip* arg5) {
//   return ((gboolean (*)(GtkSourceGutterRenderer*, GtkTextIter*, GdkRectangle*, gint, gint, GtkTooltip*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gtksource4_GutterRenderer_virtual_activate(void* fnptr, GtkSourceGutterRenderer* arg0, GtkTextIter* arg1, GdkRectangle* arg2, GdkEvent* arg3) {
//   ((void (*)(GtkSourceGutterRenderer*, GtkTextIter*, GdkRectangle*, GdkEvent*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtksource4_GutterRenderer_virtual_begin(void* fnptr, GtkSourceGutterRenderer* arg0, cairo_t* arg1, GdkRectangle* arg2, GdkRectangle* arg3, GtkTextIter* arg4, GtkTextIter* arg5) {
//   ((void (*)(GtkSourceGutterRenderer*, cairo_t*, GdkRectangle*, GdkRectangle*, GtkTextIter*, GtkTextIter*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gtksource4_GutterRenderer_virtual_change_buffer(void* fnptr, GtkSourceGutterRenderer* arg0, GtkTextBuffer* arg1) {
//   ((void (*)(GtkSourceGutterRenderer*, GtkTextBuffer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtksource4_GutterRenderer_virtual_change_view(void* fnptr, GtkSourceGutterRenderer* arg0, GtkTextView* arg1) {
//   ((void (*)(GtkSourceGutterRenderer*, GtkTextView*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtksource4_GutterRenderer_virtual_draw(void* fnptr, GtkSourceGutterRenderer* arg0, cairo_t* arg1, GdkRectangle* arg2, GdkRectangle* arg3, GtkTextIter* arg4, GtkTextIter* arg5, GtkSourceGutterRendererState arg6) {
//   ((void (*)(GtkSourceGutterRenderer*, cairo_t*, GdkRectangle*, GdkRectangle*, GtkTextIter*, GtkTextIter*, GtkSourceGutterRendererState))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gtksource4_GutterRenderer_virtual_end(void* fnptr, GtkSourceGutterRenderer* arg0) {
//   ((void (*)(GtkSourceGutterRenderer*))(fnptr))(arg0);
// };
// void _gotk4_gtksource4_GutterRenderer_virtual_query_data(void* fnptr, GtkSourceGutterRenderer* arg0, GtkTextIter* arg1, GtkTextIter* arg2, GtkSourceGutterRendererState arg3) {
//   ((void (*)(GtkSourceGutterRenderer*, GtkTextIter*, GtkTextIter*, GtkSourceGutterRendererState))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtksource4_GutterRenderer_virtual_queue_draw(void* fnptr, GtkSourceGutterRenderer* arg0) {
//   ((void (*)(GtkSourceGutterRenderer*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeGutterRendererAlignmentMode = coreglib.Type(C.gtk_source_gutter_renderer_alignment_mode_get_type())
	GTypeGutterRenderer              = coreglib.Type(C.gtk_source_gutter_renderer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGutterRendererAlignmentMode, F: marshalGutterRendererAlignmentMode},
		coreglib.TypeMarshaler{T: GTypeGutterRenderer, F: marshalGutterRenderer},
	})
}

// GutterRendererAlignmentMode: alignment mode of the renderer, when a cell
// spans multiple lines (due to text wrapping).
type GutterRendererAlignmentMode C.gint

const (
	// SourceGutterRendererAlignmentModeCell: full cell.
	SourceGutterRendererAlignmentModeCell GutterRendererAlignmentMode = iota
	// SourceGutterRendererAlignmentModeFirst: first line.
	SourceGutterRendererAlignmentModeFirst
	// SourceGutterRendererAlignmentModeLast: last line.
	SourceGutterRendererAlignmentModeLast
)

func marshalGutterRendererAlignmentMode(p uintptr) (interface{}, error) {
	return GutterRendererAlignmentMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GutterRendererAlignmentMode.
func (g GutterRendererAlignmentMode) String() string {
	switch g {
	case SourceGutterRendererAlignmentModeCell:
		return "Cell"
	case SourceGutterRendererAlignmentModeFirst:
		return "First"
	case SourceGutterRendererAlignmentModeLast:
		return "Last"
	default:
		return fmt.Sprintf("GutterRendererAlignmentMode(%d)", g)
	}
}

// GutterRendererOverrides contains methods that are overridable.
type GutterRendererOverrides struct {
	// Activate emits the SourceGutterRenderer::activate signal of the renderer.
	// This is called from SourceGutter and should never have to be called
	// manually.
	//
	// The function takes the following parameters:
	//
	//   - iter at the start of the line where the renderer is activated.
	//   - area of the cell area where the renderer is activated.
	//   - event that triggered the activation.
	//
	Activate func(iter *gtk.TextIter, area *gdk.Rectangle, event *gdk.Event)
	// Begin: called when drawing a region begins. The region to be drawn is
	// indicated by start and end. The purpose is to allow the implementation to
	// precompute some state before the draw method is called for each cell.
	//
	// The function takes the following parameters:
	//
	//   - cr: #cairo_t.
	//   - backgroundArea: Rectangle.
	//   - cellArea: Rectangle.
	//   - start: TextIter.
	//   - end: TextIter.
	//
	Begin func(cr *cairo.Context, backgroundArea, cellArea *gdk.Rectangle, start, end *gtk.TextIter)
	// ChangeBuffer: this is called when the text buffer changes for renderer.
	//
	// The function takes the following parameters:
	//
	//   - oldBuffer (optional): old TextBuffer.
	//
	ChangeBuffer func(oldBuffer *gtk.TextBuffer)
	// ChangeView: this is called when the text view changes for renderer.
	//
	// The function takes the following parameters:
	//
	//   - oldView (optional): old TextView.
	//
	ChangeView func(oldView *gtk.TextView)
	// Draw: main renderering method. Implementations should implement this
	// method to draw onto the cairo context. The background_area indicates
	// the total area of the cell to be drawn. The cell_area indicates the area
	// where content can be drawn (text, images, etc).
	//
	// The background_area is the cell_area plus the padding on each side
	// (two times the SourceGutterRenderer:xpad horizontally and two times the
	// SourceGutterRenderer:ypad vertically, so that the cell_area is centered
	// inside background_area).
	//
	// The state argument indicates the current state of the renderer and should
	// be taken into account to properly draw the different possible states
	// (cursor, prelit, selected) if appropriate.
	//
	// The function takes the following parameters:
	//
	//   - cr: cairo render context.
	//   - backgroundArea indicating the total area to be drawn.
	//   - cellArea indicating the area to draw content.
	//   - start: TextIter.
	//   - end: TextIter.
	//   - state: SourceGutterRendererState.
	//
	Draw func(cr *cairo.Context, backgroundArea, cellArea *gdk.Rectangle, start, end *gtk.TextIter, state GutterRendererState)
	// End: called when drawing a region of lines has ended.
	End func()
	// QueryActivatable: get whether the renderer is activatable at the location
	// in event. This is called from SourceGutter to determine whether a
	// renderer is activatable using the mouse pointer.
	//
	// The function takes the following parameters:
	//
	//   - iter at the start of the line to be activated.
	//   - area of the cell area to be activated.
	//   - event that triggered the query.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the renderer can be activated, FALSE otherwise.
	//
	QueryActivatable func(iter *gtk.TextIter, area *gdk.Rectangle, event *gdk.Event) bool
	// QueryData: emit the SourceGutterRenderer::query-data signal.
	// This function is called to query for data just before rendering a cell.
	// This is called from the SourceGutter. Implementations can override the
	// default signal handler or can connect a signal handler externally to the
	// SourceGutterRenderer::query-data signal.
	//
	// The function takes the following parameters:
	//
	//   - start: TextIter.
	//   - end: TextIter.
	//   - state: SourceGutterRendererState.
	//
	QueryData func(start, end *gtk.TextIter, state GutterRendererState)
	// QueryTooltip emits the SourceGutterRenderer::query-tooltip signal.
	// This function is called from SourceGutter. Implementations can override
	// the default signal handler or can connect to the signal externally.
	//
	// The function takes the following parameters:
	//
	//   - iter: TextIter.
	//   - area: Rectangle.
	//   - x position of the tooltip.
	//   - y position of the tooltip.
	//   - tooltip: Tooltip.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the tooltip has been set, FALSE otherwise.
	//
	QueryTooltip func(iter *gtk.TextIter, area *gdk.Rectangle, x, y int, tooltip *gtk.Tooltip) bool
	// QueueDraw emits the SourceGutterRenderer::queue-draw signal of the
	// renderer. Call this from an implementation to inform that the renderer
	// has changed such that it needs to redraw.
	QueueDraw func()
}

func defaultGutterRendererOverrides(v *GutterRenderer) GutterRendererOverrides {
	return GutterRendererOverrides{
		Activate:         v.activate,
		Begin:            v.begin,
		ChangeBuffer:     v.changeBuffer,
		ChangeView:       v.changeView,
		Draw:             v.draw,
		End:              v.end,
		QueryActivatable: v.queryActivatable,
		QueryData:        v.queryData,
		QueryTooltip:     v.queryTooltip,
		QueueDraw:        v.queueDraw,
	}
}

type GutterRenderer struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned
}

var ()

// GutterRendererer describes types inherited from class GutterRenderer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GutterRendererer interface {
	coreglib.Objector
	baseGutterRenderer() *GutterRenderer
}

var _ GutterRendererer = (*GutterRenderer)(nil)

func init() {
	coreglib.RegisterClassInfo[*GutterRenderer, *GutterRendererClass, GutterRendererOverrides](
		GTypeGutterRenderer,
		initGutterRendererClass,
		wrapGutterRenderer,
		defaultGutterRendererOverrides,
	)
}

func initGutterRendererClass(gclass unsafe.Pointer, overrides GutterRendererOverrides, classInitFunc func(*GutterRendererClass)) {
	pclass := (*C.GtkSourceGutterRendererClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGutterRenderer))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_activate)
	}

	if overrides.Begin != nil {
		pclass.begin = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_begin)
	}

	if overrides.ChangeBuffer != nil {
		pclass.change_buffer = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_change_buffer)
	}

	if overrides.ChangeView != nil {
		pclass.change_view = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_change_view)
	}

	if overrides.Draw != nil {
		pclass.draw = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_draw)
	}

	if overrides.End != nil {
		pclass.end = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_end)
	}

	if overrides.QueryActivatable != nil {
		pclass.query_activatable = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_query_activatable)
	}

	if overrides.QueryData != nil {
		pclass.query_data = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_query_data)
	}

	if overrides.QueryTooltip != nil {
		pclass.query_tooltip = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_query_tooltip)
	}

	if overrides.QueueDraw != nil {
		pclass.queue_draw = (*[0]byte)(C._gotk4_gtksource4_GutterRendererClass_queue_draw)
	}

	if classInitFunc != nil {
		class := (*GutterRendererClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGutterRenderer(obj *coreglib.Object) *GutterRenderer {
	return &GutterRenderer{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
	}
}

func marshalGutterRenderer(p uintptr) (interface{}, error) {
	return wrapGutterRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (renderer *GutterRenderer) baseGutterRenderer() *GutterRenderer {
	return renderer
}

// BaseGutterRenderer returns the underlying base object.
func BaseGutterRenderer(obj GutterRendererer) *GutterRenderer {
	return obj.baseGutterRenderer()
}

// ConnectActivate signal is emitted when the renderer is activated.
func (renderer *GutterRenderer) ConnectActivate(f func(iter *gtk.TextIter, area *gdk.Rectangle, event *gdk.Event)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(renderer, "activate", false, unsafe.Pointer(C._gotk4_gtksource4_GutterRenderer_ConnectActivate), f)
}

// ConnectQueryActivatable signal is emitted when the renderer can possibly be
// activated.
func (renderer *GutterRenderer) ConnectQueryActivatable(f func(iter *gtk.TextIter, area *gdk.Rectangle, event *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(renderer, "query-activatable", false, unsafe.Pointer(C._gotk4_gtksource4_GutterRenderer_ConnectQueryActivatable), f)
}

// ConnectQueryData signal is emitted when the renderer needs to be filled
// with data just before a cell is drawn. This can be used by general renderer
// implementations to allow render data to be filled in externally.
func (renderer *GutterRenderer) ConnectQueryData(f func(start, end *gtk.TextIter, state GutterRendererState)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(renderer, "query-data", false, unsafe.Pointer(C._gotk4_gtksource4_GutterRenderer_ConnectQueryData), f)
}

// ConnectQueryTooltip signal is emitted when the renderer can show a tooltip.
func (renderer *GutterRenderer) ConnectQueryTooltip(f func(iter *gtk.TextIter, area *gdk.Rectangle, x, y int, tooltip *gtk.Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(renderer, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtksource4_GutterRenderer_ConnectQueryTooltip), f)
}

// ConnectQueueDraw signal is emitted when the renderer needs to be redrawn.
// Use gtk_source_gutter_renderer_queue_draw() to emit this signal from an
// implementation of the SourceGutterRenderer interface.
func (renderer *GutterRenderer) ConnectQueueDraw(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(renderer, "queue-draw", false, unsafe.Pointer(C._gotk4_gtksource4_GutterRenderer_ConnectQueueDraw), f)
}

// Activate emits the SourceGutterRenderer::activate signal of the renderer.
// This is called from SourceGutter and should never have to be called manually.
//
// The function takes the following parameters:
//
//   - iter at the start of the line where the renderer is activated.
//   - area of the cell area where the renderer is activated.
//   - event that triggered the activation.
//
func (renderer *GutterRenderer) Activate(iter *gtk.TextIter, area *gdk.Rectangle, event *gdk.Event) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GtkTextIter             // out
	var _arg2 *C.GdkRectangle            // out
	var _arg3 *C.GdkEvent                // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))
	_arg3 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gtk_source_gutter_renderer_activate(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(area)
	runtime.KeepAlive(event)
}

// Begin: called when drawing a region begins. The region to be drawn is
// indicated by start and end. The purpose is to allow the implementation to
// precompute some state before the draw method is called for each cell.
//
// The function takes the following parameters:
//
//   - cr: #cairo_t.
//   - backgroundArea: Rectangle.
//   - cellArea: Rectangle.
//   - start: TextIter.
//   - end: TextIter.
//
func (renderer *GutterRenderer) Begin(cr *cairo.Context, backgroundArea, cellArea *gdk.Rectangle, start, end *gtk.TextIter) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.cairo_t                 // out
	var _arg2 *C.GdkRectangle            // out
	var _arg3 *C.GdkRectangle            // out
	var _arg4 *C.GtkTextIter             // out
	var _arg5 *C.GtkTextIter             // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg5 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_source_gutter_renderer_begin(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Draw: main renderering method. Implementations should implement this method
// to draw onto the cairo context. The background_area indicates the total area
// of the cell to be drawn. The cell_area indicates the area where content can
// be drawn (text, images, etc).
//
// The background_area is the cell_area plus the padding on each side
// (two times the SourceGutterRenderer:xpad horizontally and two times the
// SourceGutterRenderer:ypad vertically, so that the cell_area is centered
// inside background_area).
//
// The state argument indicates the current state of the renderer and should be
// taken into account to properly draw the different possible states (cursor,
// prelit, selected) if appropriate.
//
// The function takes the following parameters:
//
//   - cr: cairo render context.
//   - backgroundArea indicating the total area to be drawn.
//   - cellArea indicating the area to draw content.
//   - start: TextIter.
//   - end: TextIter.
//   - state: SourceGutterRendererState.
//
func (renderer *GutterRenderer) Draw(cr *cairo.Context, backgroundArea, cellArea *gdk.Rectangle, start, end *gtk.TextIter, state GutterRendererState) {
	var _arg0 *C.GtkSourceGutterRenderer     // out
	var _arg1 *C.cairo_t                     // out
	var _arg2 *C.GdkRectangle                // out
	var _arg3 *C.GdkRectangle                // out
	var _arg4 *C.GtkTextIter                 // out
	var _arg5 *C.GtkTextIter                 // out
	var _arg6 C.GtkSourceGutterRendererState // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg5 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	_arg6 = C.GtkSourceGutterRendererState(state)

	C.gtk_source_gutter_renderer_draw(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(state)
}

// End: called when drawing a region of lines has ended.
func (renderer *GutterRenderer) End() {
	var _arg0 *C.GtkSourceGutterRenderer // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gtk_source_gutter_renderer_end(_arg0)
	runtime.KeepAlive(renderer)
}

// Alignment: get the x-alignment and y-alignment of the gutter renderer.
//
// The function returns the following values:
//
//   - xalign (optional): return location for the x-alignment, or NULL to
//     ignore.
//   - yalign (optional): return location for the y-alignment, or NULL to
//     ignore.
//
func (renderer *GutterRenderer) Alignment() (xalign, yalign float32) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 C.gfloat                   // in
	var _arg2 C.gfloat                   // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gtk_source_gutter_renderer_get_alignment(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(renderer)

	var _xalign float32 // out
	var _yalign float32 // out

	_xalign = float32(_arg1)
	_yalign = float32(_arg2)

	return _xalign, _yalign
}

// AlignmentMode: get the alignment mode. The alignment mode describes the
// manner in which the renderer is aligned (see :xalign and :yalign).
//
// The function returns the following values:
//
//   - gutterRendererAlignmentMode: SourceGutterRendererAlignmentMode.
//
func (renderer *GutterRenderer) AlignmentMode() GutterRendererAlignmentMode {
	var _arg0 *C.GtkSourceGutterRenderer             // out
	var _cret C.GtkSourceGutterRendererAlignmentMode // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_source_gutter_renderer_get_alignment_mode(_arg0)
	runtime.KeepAlive(renderer)

	var _gutterRendererAlignmentMode GutterRendererAlignmentMode // out

	_gutterRendererAlignmentMode = GutterRendererAlignmentMode(_cret)

	return _gutterRendererAlignmentMode
}

// Background: get the background color of the renderer.
//
// The function returns the following values:
//
//   - color (optional): return value for a RGBA.
//   - ok: TRUE if the background color is set, FALSE otherwise.
//
func (renderer *GutterRenderer) Background() (*gdk.RGBA, bool) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 C.GdkRGBA                  // in
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_source_gutter_renderer_get_background(_arg0, &_arg1)
	runtime.KeepAlive(renderer)

	var _color *gdk.RGBA // out
	var _ok bool         // out

	_color = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _color, _ok
}

// Padding: get the x-padding and y-padding of the gutter renderer.
//
// The function returns the following values:
//
//   - xpad (optional): return location for the x-padding, or NULL to ignore.
//   - ypad (optional): return location for the y-padding, or NULL to ignore.
//
func (renderer *GutterRenderer) Padding() (xpad, ypad int) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 C.gint                     // in
	var _arg2 C.gint                     // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gtk_source_gutter_renderer_get_padding(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(renderer)

	var _xpad int // out
	var _ypad int // out

	_xpad = int(_arg1)
	_ypad = int(_arg2)

	return _xpad, _ypad
}

// Size: get the size of the renderer.
//
// The function returns the following values:
//
//   - gint: size of the renderer.
//
func (renderer *GutterRenderer) Size() int {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _cret C.gint                     // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_source_gutter_renderer_get_size(_arg0)
	runtime.KeepAlive(renderer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// View: get the view associated to the gutter renderer.
//
// The function returns the following values:
//
//   - textView: TextView.
//
func (renderer *GutterRenderer) View() *gtk.TextView {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _cret *C.GtkTextView             // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_source_gutter_renderer_get_view(_arg0)
	runtime.KeepAlive(renderer)

	var _textView *gtk.TextView // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_textView = &gtk.TextView{
			Container: gtk.Container{
				Widget: gtk.Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: gtk.Buildable{
						Object: obj,
					},
				},
			},
			Object: obj,
			Scrollable: gtk.Scrollable{
				Object: obj,
			},
		}
	}

	return _textView
}

// Visible: get whether the gutter renderer is visible.
//
// The function returns the following values:
//
//   - ok: TRUE if the renderer is visible, FALSE otherwise.
//
func (renderer *GutterRenderer) Visible() bool {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_source_gutter_renderer_get_visible(_arg0)
	runtime.KeepAlive(renderer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WindowType: get the TextWindowType associated with the gutter renderer.
//
// The function returns the following values:
//
//   - textWindowType: TextWindowType.
//
func (renderer *GutterRenderer) WindowType() gtk.TextWindowType {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _cret C.GtkTextWindowType        // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_source_gutter_renderer_get_window_type(_arg0)
	runtime.KeepAlive(renderer)

	var _textWindowType gtk.TextWindowType // out

	_textWindowType = gtk.TextWindowType(_cret)

	return _textWindowType
}

// QueryActivatable: get whether the renderer is activatable at the location in
// event. This is called from SourceGutter to determine whether a renderer is
// activatable using the mouse pointer.
//
// The function takes the following parameters:
//
//   - iter at the start of the line to be activated.
//   - area of the cell area to be activated.
//   - event that triggered the query.
//
// The function returns the following values:
//
//   - ok: TRUE if the renderer can be activated, FALSE otherwise.
//
func (renderer *GutterRenderer) QueryActivatable(iter *gtk.TextIter, area *gdk.Rectangle, event *gdk.Event) bool {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GtkTextIter             // out
	var _arg2 *C.GdkRectangle            // out
	var _arg3 *C.GdkEvent                // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))
	_arg3 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_source_gutter_renderer_query_activatable(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(area)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryData: emit the SourceGutterRenderer::query-data signal.
// This function is called to query for data just before rendering a cell.
// This is called from the SourceGutter. Implementations can override the
// default signal handler or can connect a signal handler externally to the
// SourceGutterRenderer::query-data signal.
//
// The function takes the following parameters:
//
//   - start: TextIter.
//   - end: TextIter.
//   - state: SourceGutterRendererState.
//
func (renderer *GutterRenderer) QueryData(start, end *gtk.TextIter, state GutterRendererState) {
	var _arg0 *C.GtkSourceGutterRenderer     // out
	var _arg1 *C.GtkTextIter                 // out
	var _arg2 *C.GtkTextIter                 // out
	var _arg3 C.GtkSourceGutterRendererState // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	_arg3 = C.GtkSourceGutterRendererState(state)

	C.gtk_source_gutter_renderer_query_data(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(state)
}

// QueryTooltip emits the SourceGutterRenderer::query-tooltip signal.
// This function is called from SourceGutter. Implementations can override the
// default signal handler or can connect to the signal externally.
//
// The function takes the following parameters:
//
//   - iter: TextIter.
//   - area: Rectangle.
//   - x position of the tooltip.
//   - y position of the tooltip.
//   - tooltip: Tooltip.
//
// The function returns the following values:
//
//   - ok: TRUE if the tooltip has been set, FALSE otherwise.
//
func (renderer *GutterRenderer) QueryTooltip(iter *gtk.TextIter, area *gdk.Rectangle, x, y int, tooltip *gtk.Tooltip) bool {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GtkTextIter             // out
	var _arg2 *C.GdkRectangle            // out
	var _arg3 C.gint                     // out
	var _arg4 C.gint                     // out
	var _arg5 *C.GtkTooltip              // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))
	_arg3 = C.gint(x)
	_arg4 = C.gint(y)
	_arg5 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))

	_cret = C.gtk_source_gutter_renderer_query_tooltip(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(area)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(tooltip)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueueDraw emits the SourceGutterRenderer::queue-draw signal of the renderer.
// Call this from an implementation to inform that the renderer has changed such
// that it needs to redraw.
func (renderer *GutterRenderer) QueueDraw() {
	var _arg0 *C.GtkSourceGutterRenderer // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gtk_source_gutter_renderer_queue_draw(_arg0)
	runtime.KeepAlive(renderer)
}

// SetAlignment: set the alignment of the gutter renderer. Both xalign and
// yalign can be -1, which means the values will not be changed (this allows
// changing only one of the values).
//
// xalign is the horizontal alignment. Set to 0 for a left alignment. 1 for a
// right alignment. And 0.5 for centering the cells. yalign is the vertical
// alignment. Set to 0 for a top alignment. 1 for a bottom alignment.
//
// The function takes the following parameters:
//
//   - xalign: x-alignment.
//   - yalign: y-alignment.
//
func (renderer *GutterRenderer) SetAlignment(xalign, yalign float32) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 C.gfloat                   // out
	var _arg2 C.gfloat                   // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.gfloat(xalign)
	_arg2 = C.gfloat(yalign)

	C.gtk_source_gutter_renderer_set_alignment(_arg0, _arg1, _arg2)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
}

// SetAlignmentMode: set the alignment mode. The alignment mode describes the
// manner in which the renderer is aligned (see :xalign and :yalign).
//
// The function takes the following parameters:
//
//   - mode: SourceGutterRendererAlignmentMode.
//
func (renderer *GutterRenderer) SetAlignmentMode(mode GutterRendererAlignmentMode) {
	var _arg0 *C.GtkSourceGutterRenderer             // out
	var _arg1 C.GtkSourceGutterRendererAlignmentMode // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.GtkSourceGutterRendererAlignmentMode(mode)

	C.gtk_source_gutter_renderer_set_alignment_mode(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(mode)
}

// SetBackground: set the background color of the renderer. If color is set to
// NULL, the renderer will not have a background color.
//
// The function takes the following parameters:
//
//   - color (optional) or NULL.
//
func (renderer *GutterRenderer) SetBackground(color *gdk.RGBA) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GdkRGBA                 // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if color != nil {
		_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	}

	C.gtk_source_gutter_renderer_set_background(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(color)
}

// SetPadding: set the padding of the gutter renderer. Both xpad and ypad can be
// -1, which means the values will not be changed (this allows changing only one
// of the values).
//
// xpad is the left and right padding. ypad is the top and bottom padding.
//
// The function takes the following parameters:
//
//   - xpad: x-padding.
//   - ypad: y-padding.
//
func (renderer *GutterRenderer) SetPadding(xpad, ypad int) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 C.gint                     // out
	var _arg2 C.gint                     // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.gint(xpad)
	_arg2 = C.gint(ypad)

	C.gtk_source_gutter_renderer_set_padding(_arg0, _arg1, _arg2)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(xpad)
	runtime.KeepAlive(ypad)
}

// SetSize sets the size of the renderer. A value of -1 specifies that the size
// is to be determined dynamically.
//
// The function takes the following parameters:
//
//   - size: size.
//
func (renderer *GutterRenderer) SetSize(size int) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 C.gint                     // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.gint(size)

	C.gtk_source_gutter_renderer_set_size(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(size)
}

// SetVisible: set whether the gutter renderer is visible.
//
// The function takes the following parameters:
//
//   - visible: visibility.
//
func (renderer *GutterRenderer) SetVisible(visible bool) {
	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 C.gboolean                 // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_source_gutter_renderer_set_visible(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(visible)
}

// Activate emits the SourceGutterRenderer::activate signal of the renderer.
// This is called from SourceGutter and should never have to be called manually.
//
// The function takes the following parameters:
//
//   - iter at the start of the line where the renderer is activated.
//   - area of the cell area where the renderer is activated.
//   - event that triggered the activation.
//
func (renderer *GutterRenderer) activate(iter *gtk.TextIter, area *gdk.Rectangle, event *gdk.Event) {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.activate

	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GtkTextIter             // out
	var _arg2 *C.GdkRectangle            // out
	var _arg3 *C.GdkEvent                // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))
	_arg3 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C._gotk4_gtksource4_GutterRenderer_virtual_activate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(area)
	runtime.KeepAlive(event)
}

// Begin: called when drawing a region begins. The region to be drawn is
// indicated by start and end. The purpose is to allow the implementation to
// precompute some state before the draw method is called for each cell.
//
// The function takes the following parameters:
//
//   - cr: #cairo_t.
//   - backgroundArea: Rectangle.
//   - cellArea: Rectangle.
//   - start: TextIter.
//   - end: TextIter.
//
func (renderer *GutterRenderer) begin(cr *cairo.Context, backgroundArea, cellArea *gdk.Rectangle, start, end *gtk.TextIter) {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.begin

	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.cairo_t                 // out
	var _arg2 *C.GdkRectangle            // out
	var _arg3 *C.GdkRectangle            // out
	var _arg4 *C.GtkTextIter             // out
	var _arg5 *C.GtkTextIter             // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg5 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C._gotk4_gtksource4_GutterRenderer_virtual_begin(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// changeBuffer: this is called when the text buffer changes for renderer.
//
// The function takes the following parameters:
//
//   - oldBuffer (optional): old TextBuffer.
//
func (renderer *GutterRenderer) changeBuffer(oldBuffer *gtk.TextBuffer) {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.change_buffer

	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GtkTextBuffer           // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if oldBuffer != nil {
		_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(oldBuffer).Native()))
	}

	C._gotk4_gtksource4_GutterRenderer_virtual_change_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(oldBuffer)
}

// changeView: this is called when the text view changes for renderer.
//
// The function takes the following parameters:
//
//   - oldView (optional): old TextView.
//
func (renderer *GutterRenderer) changeView(oldView *gtk.TextView) {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.change_view

	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GtkTextView             // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if oldView != nil {
		_arg1 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(oldView).Native()))
	}

	C._gotk4_gtksource4_GutterRenderer_virtual_change_view(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(oldView)
}

// Draw: main renderering method. Implementations should implement this method
// to draw onto the cairo context. The background_area indicates the total area
// of the cell to be drawn. The cell_area indicates the area where content can
// be drawn (text, images, etc).
//
// The background_area is the cell_area plus the padding on each side
// (two times the SourceGutterRenderer:xpad horizontally and two times the
// SourceGutterRenderer:ypad vertically, so that the cell_area is centered
// inside background_area).
//
// The state argument indicates the current state of the renderer and should be
// taken into account to properly draw the different possible states (cursor,
// prelit, selected) if appropriate.
//
// The function takes the following parameters:
//
//   - cr: cairo render context.
//   - backgroundArea indicating the total area to be drawn.
//   - cellArea indicating the area to draw content.
//   - start: TextIter.
//   - end: TextIter.
//   - state: SourceGutterRendererState.
//
func (renderer *GutterRenderer) draw(cr *cairo.Context, backgroundArea, cellArea *gdk.Rectangle, start, end *gtk.TextIter, state GutterRendererState) {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw

	var _arg0 *C.GtkSourceGutterRenderer     // out
	var _arg1 *C.cairo_t                     // out
	var _arg2 *C.GdkRectangle                // out
	var _arg3 *C.GdkRectangle                // out
	var _arg4 *C.GtkTextIter                 // out
	var _arg5 *C.GtkTextIter                 // out
	var _arg6 C.GtkSourceGutterRendererState // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg5 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	_arg6 = C.GtkSourceGutterRendererState(state)

	C._gotk4_gtksource4_GutterRenderer_virtual_draw(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(state)
}

// End: called when drawing a region of lines has ended.
func (renderer *GutterRenderer) end() {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.end

	var _arg0 *C.GtkSourceGutterRenderer // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C._gotk4_gtksource4_GutterRenderer_virtual_end(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(renderer)
}

// queryActivatable: get whether the renderer is activatable at the location in
// event. This is called from SourceGutter to determine whether a renderer is
// activatable using the mouse pointer.
//
// The function takes the following parameters:
//
//   - iter at the start of the line to be activated.
//   - area of the cell area to be activated.
//   - event that triggered the query.
//
// The function returns the following values:
//
//   - ok: TRUE if the renderer can be activated, FALSE otherwise.
//
func (renderer *GutterRenderer) queryActivatable(iter *gtk.TextIter, area *gdk.Rectangle, event *gdk.Event) bool {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.query_activatable

	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GtkTextIter             // out
	var _arg2 *C.GdkRectangle            // out
	var _arg3 *C.GdkEvent                // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))
	_arg3 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtksource4_GutterRenderer_virtual_query_activatable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(area)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// queryData: emit the SourceGutterRenderer::query-data signal.
// This function is called to query for data just before rendering a cell.
// This is called from the SourceGutter. Implementations can override the
// default signal handler or can connect a signal handler externally to the
// SourceGutterRenderer::query-data signal.
//
// The function takes the following parameters:
//
//   - start: TextIter.
//   - end: TextIter.
//   - state: SourceGutterRendererState.
//
func (renderer *GutterRenderer) queryData(start, end *gtk.TextIter, state GutterRendererState) {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.query_data

	var _arg0 *C.GtkSourceGutterRenderer     // out
	var _arg1 *C.GtkTextIter                 // out
	var _arg2 *C.GtkTextIter                 // out
	var _arg3 C.GtkSourceGutterRendererState // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	_arg3 = C.GtkSourceGutterRendererState(state)

	C._gotk4_gtksource4_GutterRenderer_virtual_query_data(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(state)
}

// queryTooltip emits the SourceGutterRenderer::query-tooltip signal.
// This function is called from SourceGutter. Implementations can override the
// default signal handler or can connect to the signal externally.
//
// The function takes the following parameters:
//
//   - iter: TextIter.
//   - area: Rectangle.
//   - x position of the tooltip.
//   - y position of the tooltip.
//   - tooltip: Tooltip.
//
// The function returns the following values:
//
//   - ok: TRUE if the tooltip has been set, FALSE otherwise.
//
func (renderer *GutterRenderer) queryTooltip(iter *gtk.TextIter, area *gdk.Rectangle, x, y int, tooltip *gtk.Tooltip) bool {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.query_tooltip

	var _arg0 *C.GtkSourceGutterRenderer // out
	var _arg1 *C.GtkTextIter             // out
	var _arg2 *C.GdkRectangle            // out
	var _arg3 C.gint                     // out
	var _arg4 C.gint                     // out
	var _arg5 *C.GtkTooltip              // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))
	_arg3 = C.gint(x)
	_arg4 = C.gint(y)
	_arg5 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))

	_cret = C._gotk4_gtksource4_GutterRenderer_virtual_query_tooltip(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(area)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(tooltip)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// queueDraw emits the SourceGutterRenderer::queue-draw signal of the renderer.
// Call this from an implementation to inform that the renderer has changed such
// that it needs to redraw.
func (renderer *GutterRenderer) queueDraw() {
	gclass := (*C.GtkSourceGutterRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.queue_draw

	var _arg0 *C.GtkSourceGutterRenderer // out

	_arg0 = (*C.GtkSourceGutterRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C._gotk4_gtksource4_GutterRenderer_virtual_queue_draw(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(renderer)
}

// GutterRendererClass: instance of this type is always passed by reference.
type GutterRendererClass struct {
	*gutterRendererClass
}

// gutterRendererClass is the struct that's finalized.
type gutterRendererClass struct {
	native *C.GtkSourceGutterRendererClass
}

func (g *GutterRendererClass) Padding() [20]unsafe.Pointer {
	valptr := &g.native.padding
	var _v [20]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 20; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
