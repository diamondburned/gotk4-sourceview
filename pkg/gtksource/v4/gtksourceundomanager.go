// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
// extern gboolean _gotk4_gtksource4_UndoManagerIface_can_redo(GtkSourceUndoManager*);
// extern gboolean _gotk4_gtksource4_UndoManagerIface_can_undo(GtkSourceUndoManager*);
// extern void _gotk4_gtksource4_UndoManagerIface_begin_not_undoable_action(GtkSourceUndoManager*);
// extern void _gotk4_gtksource4_UndoManagerIface_can_redo_changed(GtkSourceUndoManager*);
// extern void _gotk4_gtksource4_UndoManagerIface_can_undo_changed(GtkSourceUndoManager*);
// extern void _gotk4_gtksource4_UndoManagerIface_end_not_undoable_action(GtkSourceUndoManager*);
// extern void _gotk4_gtksource4_UndoManagerIface_redo(GtkSourceUndoManager*);
// extern void _gotk4_gtksource4_UndoManagerIface_undo(GtkSourceUndoManager*);
// extern void _gotk4_gtksource4_UndoManager_ConnectCanRedoChanged(gpointer, guintptr);
// extern void _gotk4_gtksource4_UndoManager_ConnectCanUndoChanged(gpointer, guintptr);
import "C"

// glib.Type values for gtksourceundomanager.go.
var GTypeUndoManager = externglib.Type(C.gtk_source_undo_manager_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeUndoManager, F: marshalUndoManager},
	})
}

// UndoManagerOverrider contains methods that are overridable.
type UndoManagerOverrider interface {
	// BeginNotUndoableAction: begin a not undoable action on the buffer. All
	// changes between this call and the call to
	// gtk_source_undo_manager_end_not_undoable_action() cannot be undone. This
	// function should be re-entrant.
	BeginNotUndoableAction()
	// CanRedo: get whether there are redo operations available.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if there are redo operations available, FALSE otherwise.
	//
	CanRedo() bool
	// CanRedoChanged emits the SourceUndoManager::can-redo-changed signal.
	CanRedoChanged()
	// CanUndo: get whether there are undo operations available.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if there are undo operations available, FALSE otherwise.
	//
	CanUndo() bool
	// CanUndoChanged emits the SourceUndoManager::can-undo-changed signal.
	CanUndoChanged()
	// EndNotUndoableAction ends a not undoable action on the buffer.
	EndNotUndoableAction()
	// Redo: perform a single redo. Calling this function when there are no redo
	// operations available is an error. Use gtk_source_undo_manager_can_redo()
	// to find out if there are redo operations available.
	Redo()
	// Undo: perform a single undo. Calling this function when there are no undo
	// operations available is an error. Use gtk_source_undo_manager_can_undo()
	// to find out if there are undo operations available.
	Undo()
}

//
// UndoManager wraps an interface. This means the user can get the
// underlying type by calling Cast().
type UndoManager struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*UndoManager)(nil)
)

// UndoManagerer describes UndoManager's interface methods.
type UndoManagerer interface {
	externglib.Objector

	// BeginNotUndoableAction: begin a not undoable action on the buffer.
	BeginNotUndoableAction()
	// CanRedo: get whether there are redo operations available.
	CanRedo() bool
	// CanRedoChanged emits the SourceUndoManager::can-redo-changed signal.
	CanRedoChanged()
	// CanUndo: get whether there are undo operations available.
	CanUndo() bool
	// CanUndoChanged emits the SourceUndoManager::can-undo-changed signal.
	CanUndoChanged()
	// EndNotUndoableAction ends a not undoable action on the buffer.
	EndNotUndoableAction()
	// Redo: perform a single redo.
	Redo()
	// Undo: perform a single undo.
	Undo()

	// Can-redo-changed is emitted when the ability to redo has changed.
	ConnectCanRedoChanged(func()) externglib.SignalHandle
	// Can-undo-changed is emitted when the ability to undo has changed.
	ConnectCanUndoChanged(func()) externglib.SignalHandle
}

var _ UndoManagerer = (*UndoManager)(nil)

func ifaceInitUndoManagerer(gifacePtr, data C.gpointer) {
	iface := (*C.GtkSourceUndoManagerIface)(unsafe.Pointer(gifacePtr))
	iface.begin_not_undoable_action = (*[0]byte)(C._gotk4_gtksource4_UndoManagerIface_begin_not_undoable_action)
	iface.can_redo = (*[0]byte)(C._gotk4_gtksource4_UndoManagerIface_can_redo)
	iface.can_redo_changed = (*[0]byte)(C._gotk4_gtksource4_UndoManagerIface_can_redo_changed)
	iface.can_undo = (*[0]byte)(C._gotk4_gtksource4_UndoManagerIface_can_undo)
	iface.can_undo_changed = (*[0]byte)(C._gotk4_gtksource4_UndoManagerIface_can_undo_changed)
	iface.end_not_undoable_action = (*[0]byte)(C._gotk4_gtksource4_UndoManagerIface_end_not_undoable_action)
	iface.redo = (*[0]byte)(C._gotk4_gtksource4_UndoManagerIface_redo)
	iface.undo = (*[0]byte)(C._gotk4_gtksource4_UndoManagerIface_undo)
}

//export _gotk4_gtksource4_UndoManagerIface_begin_not_undoable_action
func _gotk4_gtksource4_UndoManagerIface_begin_not_undoable_action(arg0 *C.GtkSourceUndoManager) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(UndoManagerOverrider)

	iface.BeginNotUndoableAction()
}

//export _gotk4_gtksource4_UndoManagerIface_can_redo
func _gotk4_gtksource4_UndoManagerIface_can_redo(arg0 *C.GtkSourceUndoManager) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(UndoManagerOverrider)

	ok := iface.CanRedo()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtksource4_UndoManagerIface_can_redo_changed
func _gotk4_gtksource4_UndoManagerIface_can_redo_changed(arg0 *C.GtkSourceUndoManager) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(UndoManagerOverrider)

	iface.CanRedoChanged()
}

//export _gotk4_gtksource4_UndoManagerIface_can_undo
func _gotk4_gtksource4_UndoManagerIface_can_undo(arg0 *C.GtkSourceUndoManager) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(UndoManagerOverrider)

	ok := iface.CanUndo()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtksource4_UndoManagerIface_can_undo_changed
func _gotk4_gtksource4_UndoManagerIface_can_undo_changed(arg0 *C.GtkSourceUndoManager) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(UndoManagerOverrider)

	iface.CanUndoChanged()
}

//export _gotk4_gtksource4_UndoManagerIface_end_not_undoable_action
func _gotk4_gtksource4_UndoManagerIface_end_not_undoable_action(arg0 *C.GtkSourceUndoManager) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(UndoManagerOverrider)

	iface.EndNotUndoableAction()
}

//export _gotk4_gtksource4_UndoManagerIface_redo
func _gotk4_gtksource4_UndoManagerIface_redo(arg0 *C.GtkSourceUndoManager) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(UndoManagerOverrider)

	iface.Redo()
}

//export _gotk4_gtksource4_UndoManagerIface_undo
func _gotk4_gtksource4_UndoManagerIface_undo(arg0 *C.GtkSourceUndoManager) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(UndoManagerOverrider)

	iface.Undo()
}

func wrapUndoManager(obj *externglib.Object) *UndoManager {
	return &UndoManager{
		Object: obj,
	}
}

func marshalUndoManager(p uintptr) (interface{}, error) {
	return wrapUndoManager(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtksource4_UndoManager_ConnectCanRedoChanged
func _gotk4_gtksource4_UndoManager_ConnectCanRedoChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCanRedoChanged is emitted when the ability to redo has changed.
func (manager *UndoManager) ConnectCanRedoChanged(f func()) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(manager, "can-redo-changed", false, unsafe.Pointer(C._gotk4_gtksource4_UndoManager_ConnectCanRedoChanged), f)
}

//export _gotk4_gtksource4_UndoManager_ConnectCanUndoChanged
func _gotk4_gtksource4_UndoManager_ConnectCanUndoChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCanUndoChanged is emitted when the ability to undo has changed.
func (manager *UndoManager) ConnectCanUndoChanged(f func()) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(manager, "can-undo-changed", false, unsafe.Pointer(C._gotk4_gtksource4_UndoManager_ConnectCanUndoChanged), f)
}

// BeginNotUndoableAction: begin a not undoable action on the buffer. All
// changes between this call and the call to
// gtk_source_undo_manager_end_not_undoable_action() cannot be undone. This
// function should be re-entrant.
func (manager *UndoManager) BeginNotUndoableAction() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(externglib.InternObject(manager).Native()))

	C.gtk_source_undo_manager_begin_not_undoable_action(_arg0)
	runtime.KeepAlive(manager)
}

// CanRedo: get whether there are redo operations available.
//
// The function returns the following values:
//
//    - ok: TRUE if there are redo operations available, FALSE otherwise.
//
func (manager *UndoManager) CanRedo() bool {
	var _arg0 *C.GtkSourceUndoManager // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(externglib.InternObject(manager).Native()))

	_cret = C.gtk_source_undo_manager_can_redo(_arg0)
	runtime.KeepAlive(manager)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanRedoChanged emits the SourceUndoManager::can-redo-changed signal.
func (manager *UndoManager) CanRedoChanged() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(externglib.InternObject(manager).Native()))

	C.gtk_source_undo_manager_can_redo_changed(_arg0)
	runtime.KeepAlive(manager)
}

// CanUndo: get whether there are undo operations available.
//
// The function returns the following values:
//
//    - ok: TRUE if there are undo operations available, FALSE otherwise.
//
func (manager *UndoManager) CanUndo() bool {
	var _arg0 *C.GtkSourceUndoManager // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(externglib.InternObject(manager).Native()))

	_cret = C.gtk_source_undo_manager_can_undo(_arg0)
	runtime.KeepAlive(manager)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanUndoChanged emits the SourceUndoManager::can-undo-changed signal.
func (manager *UndoManager) CanUndoChanged() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(externglib.InternObject(manager).Native()))

	C.gtk_source_undo_manager_can_undo_changed(_arg0)
	runtime.KeepAlive(manager)
}

// EndNotUndoableAction ends a not undoable action on the buffer.
func (manager *UndoManager) EndNotUndoableAction() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(externglib.InternObject(manager).Native()))

	C.gtk_source_undo_manager_end_not_undoable_action(_arg0)
	runtime.KeepAlive(manager)
}

// Redo: perform a single redo. Calling this function when there are no redo
// operations available is an error. Use gtk_source_undo_manager_can_redo() to
// find out if there are redo operations available.
func (manager *UndoManager) Redo() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(externglib.InternObject(manager).Native()))

	C.gtk_source_undo_manager_redo(_arg0)
	runtime.KeepAlive(manager)
}

// Undo: perform a single undo. Calling this function when there are no undo
// operations available is an error. Use gtk_source_undo_manager_can_undo() to
// find out if there are undo operations available.
func (manager *UndoManager) Undo() {
	var _arg0 *C.GtkSourceUndoManager // out

	_arg0 = (*C.GtkSourceUndoManager)(unsafe.Pointer(externglib.InternObject(manager).Native()))

	C.gtk_source_undo_manager_undo(_arg0)
	runtime.KeepAlive(manager)
}
