// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"context"
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
// extern void callbackDelete(gpointer);
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// void _gotk4_gio2_FileProgressCallback(goffset, goffset, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_source_file_loader_error_get_type()), F: marshalFileLoaderError},
		{T: externglib.Type(C.gtk_source_file_loader_get_type()), F: marshalFileLoaderer},
	})
}

// FileLoaderError: error code used with the GTK_SOURCE_FILE_LOADER_ERROR
// domain.
type FileLoaderError C.gint

const (
	// SourceFileLoaderErrorTooBig: file is too big.
	SourceFileLoaderErrorTooBig FileLoaderError = iota
	// SourceFileLoaderErrorEncodingAutoDetectionFailed: it is not possible to
	// detect the encoding automatically.
	SourceFileLoaderErrorEncodingAutoDetectionFailed
	// SourceFileLoaderErrorConversionFallback: there was an encoding conversion
	// error and it was needed to use a fallback character.
	SourceFileLoaderErrorConversionFallback
)

func marshalFileLoaderError(p uintptr) (interface{}, error) {
	return FileLoaderError(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileLoaderError.
func (f FileLoaderError) String() string {
	switch f {
	case SourceFileLoaderErrorTooBig:
		return "TooBig"
	case SourceFileLoaderErrorEncodingAutoDetectionFailed:
		return "EncodingAutoDetectionFailed"
	case SourceFileLoaderErrorConversionFallback:
		return "ConversionFallback"
	default:
		return fmt.Sprintf("FileLoaderError(%d)", f)
	}
}

type FileLoader struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*FileLoader)(nil)
)

func wrapFileLoader(obj *externglib.Object) *FileLoader {
	return &FileLoader{
		Object: obj,
	}
}

func marshalFileLoaderer(p uintptr) (interface{}, error) {
	return wrapFileLoader(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFileLoader creates a new SourceFileLoader object. The contents is read
// from the SourceFile's location. If not already done, call
// gtk_source_file_set_location() before calling this constructor. The previous
// location is anyway not needed, because as soon as the file loading begins,
// the buffer is emptied.
//
// The function takes the following parameters:
//
//    - buffer to load the contents into.
//    - file: SourceFile.
//
// The function returns the following values:
//
//    - fileLoader: new SourceFileLoader object.
//
func NewFileLoader(buffer *Buffer, file *File) *FileLoader {
	var _arg1 *C.GtkSourceBuffer     // out
	var _arg2 *C.GtkSourceFile       // out
	var _cret *C.GtkSourceFileLoader // in

	_arg1 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = (*C.GtkSourceFile)(unsafe.Pointer(file.Native()))

	_cret = C.gtk_source_file_loader_new(_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(file)

	var _fileLoader *FileLoader // out

	_fileLoader = wrapFileLoader(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileLoader
}

// NewFileLoaderFromStream creates a new SourceFileLoader object. The contents
// is read from stream.
//
// The function takes the following parameters:
//
//    - buffer to load the contents into.
//    - file: SourceFile.
//    - stream to load, e.g. stdin.
//
// The function returns the following values:
//
//    - fileLoader: new SourceFileLoader object.
//
func NewFileLoaderFromStream(buffer *Buffer, file *File, stream gio.InputStreamer) *FileLoader {
	var _arg1 *C.GtkSourceBuffer     // out
	var _arg2 *C.GtkSourceFile       // out
	var _arg3 *C.GInputStream        // out
	var _cret *C.GtkSourceFileLoader // in

	_arg1 = (*C.GtkSourceBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = (*C.GtkSourceFile)(unsafe.Pointer(file.Native()))
	_arg3 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))

	_cret = C.gtk_source_file_loader_new_from_stream(_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(file)
	runtime.KeepAlive(stream)

	var _fileLoader *FileLoader // out

	_fileLoader = wrapFileLoader(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileLoader
}

// The function returns the following values:
//
//    - buffer to load the contents into.
//
func (loader *FileLoader) Buffer() *Buffer {
	var _arg0 *C.GtkSourceFileLoader // out
	var _cret *C.GtkSourceBuffer     // in

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))

	_cret = C.gtk_source_file_loader_get_buffer(_arg0)
	runtime.KeepAlive(loader)

	var _buffer *Buffer // out

	_buffer = wrapBuffer(externglib.Take(unsafe.Pointer(_cret)))

	return _buffer
}

// The function returns the following values:
//
//    - compressionType: detected compression type.
//
func (loader *FileLoader) CompressionType() CompressionType {
	var _arg0 *C.GtkSourceFileLoader     // out
	var _cret C.GtkSourceCompressionType // in

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))

	_cret = C.gtk_source_file_loader_get_compression_type(_arg0)
	runtime.KeepAlive(loader)

	var _compressionType CompressionType // out

	_compressionType = CompressionType(_cret)

	return _compressionType
}

// The function returns the following values:
//
//    - encoding: detected file encoding.
//
func (loader *FileLoader) Encoding() *Encoding {
	var _arg0 *C.GtkSourceFileLoader // out
	var _cret *C.GtkSourceEncoding   // in

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))

	_cret = C.gtk_source_file_loader_get_encoding(_arg0)
	runtime.KeepAlive(loader)

	var _encoding *Encoding // out

	_encoding = (*Encoding)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _encoding
}

// The function returns the following values:
//
//    - file: SourceFile.
//
func (loader *FileLoader) File() *File {
	var _arg0 *C.GtkSourceFileLoader // out
	var _cret *C.GtkSourceFile       // in

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))

	_cret = C.gtk_source_file_loader_get_file(_arg0)
	runtime.KeepAlive(loader)

	var _file *File // out

	_file = wrapFile(externglib.Take(unsafe.Pointer(_cret)))

	return _file
}

// The function returns the following values:
//
//    - inputStream (optional) to load, or NULL if a #GFile is used.
//
func (loader *FileLoader) InputStream() gio.InputStreamer {
	var _arg0 *C.GtkSourceFileLoader // out
	var _cret *C.GInputStream        // in

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))

	_cret = C.gtk_source_file_loader_get_input_stream(_arg0)
	runtime.KeepAlive(loader)

	var _inputStream gio.InputStreamer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gio.InputStreamer)
				return ok
			})
			rv, ok := casted.(gio.InputStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
			}
			_inputStream = rv
		}
	}

	return _inputStream
}

// The function returns the following values:
//
//    - file (optional) to load, or NULL if an input stream is used.
//
func (loader *FileLoader) Location() gio.Filer {
	var _arg0 *C.GtkSourceFileLoader // out
	var _cret *C.GFile               // in

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))

	_cret = C.gtk_source_file_loader_get_location(_arg0)
	runtime.KeepAlive(loader)

	var _file gio.Filer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(gio.Filer)
				return ok
			})
			rv, ok := casted.(gio.Filer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
			}
			_file = rv
		}
	}

	return _file
}

// The function returns the following values:
//
//    - newlineType: detected newline type.
//
func (loader *FileLoader) NewlineType() NewlineType {
	var _arg0 *C.GtkSourceFileLoader // out
	var _cret C.GtkSourceNewlineType // in

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))

	_cret = C.gtk_source_file_loader_get_newline_type(_arg0)
	runtime.KeepAlive(loader)

	var _newlineType NewlineType // out

	_newlineType = NewlineType(_cret)

	return _newlineType
}

// LoadAsync loads asynchronously the file or input stream contents into the
// SourceBuffer. See the Result documentation to know how to use this function.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: i/O priority of the request. E.g. G_PRIORITY_LOW,
//      G_PRIORITY_DEFAULT or G_PRIORITY_HIGH.
//    - progressCallback (optional): function to call back with progress
//      information, or NULL if progress information is not needed.
//    - callback (optional) to call when the request is satisfied.
//
func (loader *FileLoader) LoadAsync(ctx context.Context, ioPriority int, progressCallback gio.FileProgressCallback, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GtkSourceFileLoader  // out
	var _arg2 *C.GCancellable         // out
	var _arg1 C.gint                  // out
	var _arg3 C.GFileProgressCallback // out
	var _arg4 C.gpointer
	var _arg5 C.GDestroyNotify
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.gint(ioPriority)
	if progressCallback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_FileProgressCallback)
		_arg4 = C.gpointer(gbox.Assign(progressCallback))
		_arg5 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gtk_source_file_loader_load_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(loader)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(progressCallback)
	runtime.KeepAlive(callback)
}

// LoadFinish finishes a file loading started with
// gtk_source_file_loader_load_async().
//
// If the contents has been loaded, the following SourceFile properties will be
// updated: the location, the encoding, the newline type and the compression
// type.
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (loader *FileLoader) LoadFinish(result gio.AsyncResulter) error {
	var _arg0 *C.GtkSourceFileLoader // out
	var _arg1 *C.GAsyncResult        // out
	var _cerr *C.GError              // in

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.gtk_source_file_loader_load_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(loader)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetCandidateEncodings sets the candidate encodings for the file loading. The
// encodings are tried in the same order as the list.
//
// For convenience, candidate_encodings can contain duplicates. Only the first
// occurrence of a duplicated encoding is kept in the list.
//
// By default the candidate encodings are (in that order in the list): 1. If
// set, the SourceFile's encoding as returned by gtk_source_file_get_encoding().
// 2. The default candidates as returned by
// gtk_source_encoding_get_default_candidates().
//
// The function takes the following parameters:
//
//    - candidateEncodings: list of SourceEncoding<!-- -->s.
//
func (loader *FileLoader) SetCandidateEncodings(candidateEncodings []*Encoding) {
	var _arg0 *C.GtkSourceFileLoader // out
	var _arg1 *C.GSList              // out

	_arg0 = (*C.GtkSourceFileLoader)(unsafe.Pointer(loader.Native()))
	for i := len(candidateEncodings) - 1; i >= 0; i-- {
		src := candidateEncodings[i]
		var dst *C.GtkSourceEncoding // out
		dst = (*C.GtkSourceEncoding)(gextras.StructNative(unsafe.Pointer(src)))
		_arg1 = C.g_slist_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_slist_free(_arg1)

	C.gtk_source_file_loader_set_candidate_encodings(_arg0, _arg1)
	runtime.KeepAlive(loader)
	runtime.KeepAlive(candidateEncodings)
}
