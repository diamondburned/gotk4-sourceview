// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
// extern gboolean _gotk4_gtksource4_CompletionClass_proposal_activated(GtkSourceCompletion*, GtkSourceCompletionProvider*, GtkSourceCompletionProposal*);
// extern void _gotk4_gtksource4_CompletionClass_activate_proposal(GtkSourceCompletion*);
// extern void _gotk4_gtksource4_CompletionClass_hide(GtkSourceCompletion*);
// extern void _gotk4_gtksource4_CompletionClass_move_cursor(GtkSourceCompletion*, GtkScrollStep, gint);
// extern void _gotk4_gtksource4_CompletionClass_move_page(GtkSourceCompletion*, GtkScrollStep, gint);
// extern void _gotk4_gtksource4_CompletionClass_populate_context(GtkSourceCompletion*, GtkSourceCompletionContext*);
// extern void _gotk4_gtksource4_CompletionClass_show(GtkSourceCompletion*);
// extern void _gotk4_gtksource4_Completion_ConnectActivateProposal(gpointer, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectHide(gpointer, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectMoveCursor(gpointer, GtkScrollStep, gint, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectMovePage(gpointer, GtkScrollStep, gint, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectPopulateContext(gpointer, GtkSourceCompletionContext*, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectShow(gpointer, guintptr);
import "C"

// glib.Type values for gtksourcecompletion.go.
var (
	GTypeCompletionError = externglib.Type(C.gtk_source_completion_error_get_type())
	GTypeCompletion      = externglib.Type(C.gtk_source_completion_get_type())
)

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeCompletionError, F: marshalCompletionError},
		{T: GTypeCompletion, F: marshalCompletion},
	})
}

// CompletionError: error code used with GTK_SOURCE_COMPLETION_ERROR in a
// #GError returned from a completion-related function.
type CompletionError C.gint

const (
	// SourceCompletionErrorAlreadyBound already bound to the SourceCompletion
	// object.
	SourceCompletionErrorAlreadyBound CompletionError = iota
	// SourceCompletionErrorNotBound is not bound to the SourceCompletion
	// object.
	SourceCompletionErrorNotBound
)

func marshalCompletionError(p uintptr) (interface{}, error) {
	return CompletionError(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CompletionError.
func (c CompletionError) String() string {
	switch c {
	case SourceCompletionErrorAlreadyBound:
		return "AlreadyBound"
	case SourceCompletionErrorNotBound:
		return "NotBound"
	default:
		return fmt.Sprintf("CompletionError(%d)", c)
	}
}

// CompletionOverrider contains methods that are overridable.
type CompletionOverrider interface {
	ActivateProposal()
	// Hide hides the completion if it is active (visible).
	Hide()
	// The function takes the following parameters:
	//
	//    - step
	//    - num
	//
	MoveCursor(step gtk.ScrollStep, num int)
	// The function takes the following parameters:
	//
	//    - step
	//    - num
	//
	MovePage(step gtk.ScrollStep, num int)
	// The function takes the following parameters:
	//
	PopulateContext(context *CompletionContext)
	// The function takes the following parameters:
	//
	//    - provider
	//    - proposal
	//
	// The function returns the following values:
	//
	ProposalActivated(provider CompletionProviderer, proposal CompletionProposaller) bool
	Show()
}

type Completion struct {
	_ [0]func() // equal guard
	*externglib.Object

	gtk.Buildable
}

var (
	_ externglib.Objector = (*Completion)(nil)
)

func classInitCompletioner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkSourceCompletionClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkSourceCompletionClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ ActivateProposal() }); ok {
		pclass.activate_proposal = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_activate_proposal)
	}

	if _, ok := goval.(interface{ Hide() }); ok {
		pclass.hide = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_hide)
	}

	if _, ok := goval.(interface {
		MoveCursor(step gtk.ScrollStep, num int)
	}); ok {
		pclass.move_cursor = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_move_cursor)
	}

	if _, ok := goval.(interface {
		MovePage(step gtk.ScrollStep, num int)
	}); ok {
		pclass.move_page = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_move_page)
	}

	if _, ok := goval.(interface {
		PopulateContext(context *CompletionContext)
	}); ok {
		pclass.populate_context = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_populate_context)
	}

	if _, ok := goval.(interface {
		ProposalActivated(provider CompletionProviderer, proposal CompletionProposaller) bool
	}); ok {
		pclass.proposal_activated = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_proposal_activated)
	}

	if _, ok := goval.(interface{ Show() }); ok {
		pclass.show = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_show)
	}
}

//export _gotk4_gtksource4_CompletionClass_activate_proposal
func _gotk4_gtksource4_CompletionClass_activate_proposal(arg0 *C.GtkSourceCompletion) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ActivateProposal() })

	iface.ActivateProposal()
}

//export _gotk4_gtksource4_CompletionClass_hide
func _gotk4_gtksource4_CompletionClass_hide(arg0 *C.GtkSourceCompletion) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Hide() })

	iface.Hide()
}

//export _gotk4_gtksource4_CompletionClass_move_cursor
func _gotk4_gtksource4_CompletionClass_move_cursor(arg0 *C.GtkSourceCompletion, arg1 C.GtkScrollStep, arg2 C.gint) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		MoveCursor(step gtk.ScrollStep, num int)
	})

	var _step gtk.ScrollStep // out
	var _num int             // out

	_step = gtk.ScrollStep(arg1)
	_num = int(arg2)

	iface.MoveCursor(_step, _num)
}

//export _gotk4_gtksource4_CompletionClass_move_page
func _gotk4_gtksource4_CompletionClass_move_page(arg0 *C.GtkSourceCompletion, arg1 C.GtkScrollStep, arg2 C.gint) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		MovePage(step gtk.ScrollStep, num int)
	})

	var _step gtk.ScrollStep // out
	var _num int             // out

	_step = gtk.ScrollStep(arg1)
	_num = int(arg2)

	iface.MovePage(_step, _num)
}

//export _gotk4_gtksource4_CompletionClass_populate_context
func _gotk4_gtksource4_CompletionClass_populate_context(arg0 *C.GtkSourceCompletion, arg1 *C.GtkSourceCompletionContext) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PopulateContext(context *CompletionContext)
	})

	var _context *CompletionContext // out

	_context = wrapCompletionContext(externglib.Take(unsafe.Pointer(arg1)))

	iface.PopulateContext(_context)
}

//export _gotk4_gtksource4_CompletionClass_proposal_activated
func _gotk4_gtksource4_CompletionClass_proposal_activated(arg0 *C.GtkSourceCompletion, arg1 *C.GtkSourceCompletionProvider, arg2 *C.GtkSourceCompletionProposal) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ProposalActivated(provider CompletionProviderer, proposal CompletionProposaller) bool
	})

	var _provider CompletionProviderer  // out
	var _proposal CompletionProposaller // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtksource.CompletionProviderer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CompletionProviderer)
			return ok
		})
		rv, ok := casted.(CompletionProviderer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtksource.CompletionProviderer")
		}
		_provider = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtksource.CompletionProposaller is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CompletionProposaller)
			return ok
		})
		rv, ok := casted.(CompletionProposaller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtksource.CompletionProposaller")
		}
		_proposal = rv
	}

	ok := iface.ProposalActivated(_provider, _proposal)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtksource4_CompletionClass_show
func _gotk4_gtksource4_CompletionClass_show(arg0 *C.GtkSourceCompletion) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Show() })

	iface.Show()
}

func wrapCompletion(obj *externglib.Object) *Completion {
	return &Completion{
		Object: obj,
		Buildable: gtk.Buildable{
			Object: obj,
		},
	}
}

func marshalCompletion(p uintptr) (interface{}, error) {
	return wrapCompletion(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtksource4_Completion_ConnectActivateProposal
func _gotk4_gtksource4_Completion_ConnectActivateProposal(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivateProposal signal is a keybinding signal which gets emitted when
// the user initiates a proposal activation.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the proposal activation
// programmatically.
func (completion *Completion) ConnectActivateProposal(f func()) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(completion, "activate-proposal", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectActivateProposal), f)
}

//export _gotk4_gtksource4_Completion_ConnectHide
func _gotk4_gtksource4_Completion_ConnectHide(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectHide is emitted when the completion window is hidden. The default
// handler will actually hide the window.
func (completion *Completion) ConnectHide(f func()) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(completion, "hide", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectHide), f)
}

//export _gotk4_gtksource4_Completion_ConnectMoveCursor
func _gotk4_gtksource4_Completion_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkScrollStep, arg2 C.gint, arg3 C.guintptr) {
	var f func(step gtk.ScrollStep, num int)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step gtk.ScrollStep, num int))
	}

	var _step gtk.ScrollStep // out
	var _num int             // out

	_step = gtk.ScrollStep(arg1)
	_num = int(arg2)

	f(_step, _num)
}

// ConnectMoveCursor signal is a keybinding signal which gets emitted when the
// user initiates a cursor movement.
//
// The <keycap>Up</keycap>, <keycap>Down</keycap>, <keycap>PageUp</keycap>,
// <keycap>PageDown</keycap>, <keycap>Home</keycap> and <keycap>End</keycap>
// keys are bound to the normal behavior expected by those keys.
//
// When step is equal to GTK_SCROLL_PAGES, the page size is defined by the
// SourceCompletion:proposal-page-size property. It is used for the
// <keycap>PageDown</keycap> and <keycap>PageUp</keycap> keys.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
func (completion *Completion) ConnectMoveCursor(f func(step gtk.ScrollStep, num int)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(completion, "move-cursor", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectMoveCursor), f)
}

//export _gotk4_gtksource4_Completion_ConnectMovePage
func _gotk4_gtksource4_Completion_ConnectMovePage(arg0 C.gpointer, arg1 C.GtkScrollStep, arg2 C.gint, arg3 C.guintptr) {
	var f func(step gtk.ScrollStep, num int)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step gtk.ScrollStep, num int))
	}

	var _step gtk.ScrollStep // out
	var _num int             // out

	_step = gtk.ScrollStep(arg1)
	_num = int(arg2)

	f(_step, _num)
}

// ConnectMovePage signal is a keybinding signal which gets emitted when the
// user initiates a page movement (i.e. switches between provider pages).
//
// <keycombo><keycap>Control</keycap><keycap>Left</keycap></keycombo> is for
// going to the previous provider.
// <keycombo><keycap>Control</keycap><keycap>Right</keycap></keycombo> is for
// going to the next provider.
// <keycombo><keycap>Control</keycap><keycap>Home</keycap></keycombo> is for
// displaying all the providers.
// <keycombo><keycap>Control</keycap><keycap>End</keycap></keycombo> is for
// going to the last provider.
//
// When step is equal to K_SCROLL_PAGES, the page size is defined by the
// SourceCompletion:provider-page-size property.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the page selection
// programmatically.
func (completion *Completion) ConnectMovePage(f func(step gtk.ScrollStep, num int)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(completion, "move-page", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectMovePage), f)
}

//export _gotk4_gtksource4_Completion_ConnectPopulateContext
func _gotk4_gtksource4_Completion_ConnectPopulateContext(arg0 C.gpointer, arg1 *C.GtkSourceCompletionContext, arg2 C.guintptr) {
	var f func(context *CompletionContext)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *CompletionContext))
	}

	var _context *CompletionContext // out

	_context = wrapCompletionContext(externglib.Take(unsafe.Pointer(arg1)))

	f(_context)
}

// ConnectPopulateContext is emitted just before starting to populate the
// completion with providers. You can use this signal to add additional
// attributes in the context.
func (completion *Completion) ConnectPopulateContext(f func(context *CompletionContext)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(completion, "populate-context", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectPopulateContext), f)
}

//export _gotk4_gtksource4_Completion_ConnectShow
func _gotk4_gtksource4_Completion_ConnectShow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectShow is emitted when the completion window is shown. The default
// handler will actually show the window.
func (completion *Completion) ConnectShow(f func()) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(completion, "show", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectShow), f)
}

// AddProvider: add a new SourceCompletionProvider to the completion object.
// This will add a reference provider, so make sure to unref your own copy when
// you no longer need it.
//
// The function takes the following parameters:
//
//    - provider: SourceCompletionProvider.
//
func (completion *Completion) AddProvider(provider CompletionProviderer) error {
	var _arg0 *C.GtkSourceCompletion         // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _cerr *C.GError                      // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(externglib.InternObject(provider).Native()))

	C.gtk_source_completion_add_provider(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(provider)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// BlockInteractive: block interactive completion. This can be used to disable
// interactive completion when inserting or deleting text from the buffer
// associated with the completion. Use
// gtk_source_completion_unblock_interactive() to enable interactive completion
// again.
//
// This function may be called multiple times. It will continue to block
// interactive completion until gtk_source_completion_unblock_interactive() has
// been called the same number of times.
func (completion *Completion) BlockInteractive() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))

	C.gtk_source_completion_block_interactive(_arg0)
	runtime.KeepAlive(completion)
}

// CreateContext: create a new SourceCompletionContext for completion. The
// position where the completion occurs can be specified by position. If
// position is NULL, the current cursor position will be used.
//
// The function takes the following parameters:
//
//    - position (optional) or NULL.
//
// The function returns the following values:
//
//    - completionContext: new SourceCompletionContext. The reference being
//      returned is a 'floating' reference, so if you invoke
//      gtk_source_completion_start() with this context you don't need to unref
//      it.
//
func (completion *Completion) CreateContext(position *gtk.TextIter) *CompletionContext {
	var _arg0 *C.GtkSourceCompletion        // out
	var _arg1 *C.GtkTextIter                // out
	var _cret *C.GtkSourceCompletionContext // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))
	if position != nil {
		_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(position)))
	}

	_cret = C.gtk_source_completion_create_context(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(position)

	var _completionContext *CompletionContext // out

	_completionContext = wrapCompletionContext(externglib.Take(unsafe.Pointer(_cret)))

	return _completionContext
}

// InfoWindow: info widget is the window where the completion displays optional
// extra information of the proposal.
//
// The function returns the following values:
//
//    - completionInfo window associated with completion.
//
func (completion *Completion) InfoWindow() *CompletionInfo {
	var _arg0 *C.GtkSourceCompletion     // out
	var _cret *C.GtkSourceCompletionInfo // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))

	_cret = C.gtk_source_completion_get_info_window(_arg0)
	runtime.KeepAlive(completion)

	var _completionInfo *CompletionInfo // out

	_completionInfo = wrapCompletionInfo(externglib.Take(unsafe.Pointer(_cret)))

	return _completionInfo
}

// Providers: get list of providers registered on completion. The returned list
// is owned by the completion and should not be freed.
//
// The function returns the following values:
//
//    - list of SourceCompletionProvider.
//
func (completion *Completion) Providers() []CompletionProviderer {
	var _arg0 *C.GtkSourceCompletion // out
	var _cret *C.GList               // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))

	_cret = C.gtk_source_completion_get_providers(_arg0)
	runtime.KeepAlive(completion)

	var _list []CompletionProviderer // out

	_list = make([]CompletionProviderer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkSourceCompletionProvider)(v)
		var dst CompletionProviderer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtksource.CompletionProviderer is nil")
			}

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(CompletionProviderer)
				return ok
			})
			rv, ok := casted.(CompletionProviderer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtksource.CompletionProviderer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// View associated with completion, or NULL if the view has been destroyed.
//
// The function returns the following values:
//
//    - view (optional) associated with completion, or NULL.
//
func (completion *Completion) View() *View {
	var _arg0 *C.GtkSourceCompletion // out
	var _cret *C.GtkSourceView       // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))

	_cret = C.gtk_source_completion_get_view(_arg0)
	runtime.KeepAlive(completion)

	var _view *View // out

	if _cret != nil {
		_view = wrapView(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _view
}

// Hide hides the completion if it is active (visible).
func (completion *Completion) Hide() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))

	C.gtk_source_completion_hide(_arg0)
	runtime.KeepAlive(completion)
}

// RemoveProvider: remove provider from the completion.
//
// The function takes the following parameters:
//
//    - provider: SourceCompletionProvider.
//
func (completion *Completion) RemoveProvider(provider CompletionProviderer) error {
	var _arg0 *C.GtkSourceCompletion         // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _cerr *C.GError                      // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(externglib.InternObject(provider).Native()))

	C.gtk_source_completion_remove_provider(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(provider)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Start starts a new completion with the specified SourceCompletionContext and
// a list of potential candidate providers for completion.
//
// It can be convenient for showing a completion on-the-fly, without the need to
// add or remove providers to the SourceCompletion.
//
// Another solution is to add providers with
// gtk_source_completion_add_provider(), and implement
// gtk_source_completion_provider_match() for each provider.
//
// The function takes the following parameters:
//
//    - providers (optional): a list of SourceCompletionProvider, or NULL.
//    - context which to start the completion.
//
// The function returns the following values:
//
//    - ok: TRUE if it was possible to the show completion window.
//
func (completion *Completion) Start(providers []CompletionProviderer, context *CompletionContext) bool {
	var _arg0 *C.GtkSourceCompletion        // out
	var _arg1 *C.GList                      // out
	var _arg2 *C.GtkSourceCompletionContext // out
	var _cret C.gboolean                    // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))
	if providers != nil {
		for i := len(providers) - 1; i >= 0; i-- {
			src := providers[i]
			var dst *C.GtkSourceCompletionProvider // out
			dst = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(externglib.InternObject(src).Native()))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	_arg2 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(externglib.InternObject(context).Native()))

	_cret = C.gtk_source_completion_start(_arg0, _arg1, _arg2)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(providers)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnblockInteractive: unblock interactive completion. This can be used after
// using gtk_source_completion_block_interactive() to enable interactive
// completion again.
func (completion *Completion) UnblockInteractive() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(externglib.InternObject(completion).Native()))

	C.gtk_source_completion_unblock_interactive(_arg0)
	runtime.KeepAlive(completion)
}
