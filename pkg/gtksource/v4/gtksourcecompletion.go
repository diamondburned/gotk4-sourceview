// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_source_completion_error_get_type()), F: marshalCompletionError},
		{T: externglib.Type(C.gtk_source_completion_get_type()), F: marshalCompletioner},
	})
}

// CompletionError: error code used with GTK_SOURCE_COMPLETION_ERROR in a
// #GError returned from a completion-related function.
type CompletionError C.gint

const (
	// SourceCompletionErrorAlreadyBound already bound to the SourceCompletion
	// object.
	SourceCompletionErrorAlreadyBound CompletionError = iota
	// SourceCompletionErrorNotBound is not bound to the SourceCompletion
	// object.
	SourceCompletionErrorNotBound
)

func marshalCompletionError(p uintptr) (interface{}, error) {
	return CompletionError(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CompletionError.
func (c CompletionError) String() string {
	switch c {
	case SourceCompletionErrorAlreadyBound:
		return "AlreadyBound"
	case SourceCompletionErrorNotBound:
		return "NotBound"
	default:
		return fmt.Sprintf("CompletionError(%d)", c)
	}
}

// CompletionOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type CompletionOverrider interface {
	ActivateProposal()
	// Hide hides the completion if it is active (visible).
	Hide()
	// The function takes the following parameters:
	//
	//    - step
	//    - num
	//
	MoveCursor(step gtk.ScrollStep, num int)
	// The function takes the following parameters:
	//
	//    - step
	//    - num
	//
	MovePage(step gtk.ScrollStep, num int)
	// The function takes the following parameters:
	//
	PopulateContext(context *CompletionContext)
	// The function takes the following parameters:
	//
	//    - provider
	//    - proposal
	//
	// The function returns the following values:
	//
	ProposalActivated(provider CompletionProviderer, proposal CompletionProposaller) bool
	Show()
}

type Completion struct {
	_ [0]func() // equal guard
	*externglib.Object

	gtk.Buildable
}

var (
	_ externglib.Objector = (*Completion)(nil)
)

func wrapCompletion(obj *externglib.Object) *Completion {
	return &Completion{
		Object: obj,
		Buildable: gtk.Buildable{
			Object: obj,
		},
	}
}

func marshalCompletioner(p uintptr) (interface{}, error) {
	return wrapCompletion(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateProposal signal is a keybinding signal which gets emitted when
// the user initiates a proposal activation.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the proposal activation
// programmatically.
func (completion *Completion) ConnectActivateProposal(f func()) externglib.SignalHandle {
	return completion.Connect("activate-proposal", f)
}

// ConnectHide: emitted when the completion window is hidden. The default
// handler will actually hide the window.
func (completion *Completion) ConnectHide(f func()) externglib.SignalHandle {
	return completion.Connect("hide", f)
}

// ConnectMoveCursor signal is a keybinding signal which gets emitted when the
// user initiates a cursor movement.
//
// The <keycap>Up</keycap>, <keycap>Down</keycap>, <keycap>PageUp</keycap>,
// <keycap>PageDown</keycap>, <keycap>Home</keycap> and <keycap>End</keycap>
// keys are bound to the normal behavior expected by those keys.
//
// When step is equal to GTK_SCROLL_PAGES, the page size is defined by the
// SourceCompletion:proposal-page-size property. It is used for the
// <keycap>PageDown</keycap> and <keycap>PageUp</keycap> keys.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
func (completion *Completion) ConnectMoveCursor(f func(step gtk.ScrollStep, num int)) externglib.SignalHandle {
	return completion.Connect("move-cursor", f)
}

// ConnectMovePage signal is a keybinding signal which gets emitted when the
// user initiates a page movement (i.e. switches between provider pages).
//
// <keycombo><keycap>Control</keycap><keycap>Left</keycap></keycombo> is for
// going to the previous provider.
// <keycombo><keycap>Control</keycap><keycap>Right</keycap></keycombo> is for
// going to the next provider.
// <keycombo><keycap>Control</keycap><keycap>Home</keycap></keycombo> is for
// displaying all the providers.
// <keycombo><keycap>Control</keycap><keycap>End</keycap></keycombo> is for
// going to the last provider.
//
// When step is equal to K_SCROLL_PAGES, the page size is defined by the
// SourceCompletion:provider-page-size property.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the page selection
// programmatically.
func (completion *Completion) ConnectMovePage(f func(step gtk.ScrollStep, num int)) externglib.SignalHandle {
	return completion.Connect("move-page", f)
}

// ConnectPopulateContext: emitted just before starting to populate the
// completion with providers. You can use this signal to add additional
// attributes in the context.
func (completion *Completion) ConnectPopulateContext(f func(context CompletionContext)) externglib.SignalHandle {
	return completion.Connect("populate-context", f)
}

// ConnectShow: emitted when the completion window is shown. The default handler
// will actually show the window.
func (completion *Completion) ConnectShow(f func()) externglib.SignalHandle {
	return completion.Connect("show", f)
}

// AddProvider: add a new SourceCompletionProvider to the completion object.
// This will add a reference provider, so make sure to unref your own copy when
// you no longer need it.
//
// The function takes the following parameters:
//
//    - provider: SourceCompletionProvider.
//
func (completion *Completion) AddProvider(provider CompletionProviderer) error {
	var _arg0 *C.GtkSourceCompletion         // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _cerr *C.GError                      // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(provider.Native()))

	C.gtk_source_completion_add_provider(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(provider)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// BlockInteractive: block interactive completion. This can be used to disable
// interactive completion when inserting or deleting text from the buffer
// associated with the completion. Use
// gtk_source_completion_unblock_interactive() to enable interactive completion
// again.
//
// This function may be called multiple times. It will continue to block
// interactive completion until gtk_source_completion_unblock_interactive() has
// been called the same number of times.
func (completion *Completion) BlockInteractive() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))

	C.gtk_source_completion_block_interactive(_arg0)
	runtime.KeepAlive(completion)
}

// CreateContext: create a new SourceCompletionContext for completion. The
// position where the completion occurs can be specified by position. If
// position is NULL, the current cursor position will be used.
//
// The function takes the following parameters:
//
//    - position (optional) or NULL.
//
// The function returns the following values:
//
//    - completionContext: new SourceCompletionContext. The reference being
//      returned is a 'floating' reference, so if you invoke
//      gtk_source_completion_start() with this context you don't need to unref
//      it.
//
func (completion *Completion) CreateContext(position *gtk.TextIter) *CompletionContext {
	var _arg0 *C.GtkSourceCompletion        // out
	var _arg1 *C.GtkTextIter                // out
	var _cret *C.GtkSourceCompletionContext // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))
	if position != nil {
		_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(position)))
	}

	_cret = C.gtk_source_completion_create_context(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(position)

	var _completionContext *CompletionContext // out

	_completionContext = wrapCompletionContext(externglib.Take(unsafe.Pointer(_cret)))

	return _completionContext
}

// InfoWindow: info widget is the window where the completion displays optional
// extra information of the proposal.
//
// The function returns the following values:
//
//    - completionInfo window associated with completion.
//
func (completion *Completion) InfoWindow() *CompletionInfo {
	var _arg0 *C.GtkSourceCompletion     // out
	var _cret *C.GtkSourceCompletionInfo // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))

	_cret = C.gtk_source_completion_get_info_window(_arg0)
	runtime.KeepAlive(completion)

	var _completionInfo *CompletionInfo // out

	_completionInfo = wrapCompletionInfo(externglib.Take(unsafe.Pointer(_cret)))

	return _completionInfo
}

// Providers: get list of providers registered on completion. The returned list
// is owned by the completion and should not be freed.
//
// The function returns the following values:
//
//    - list of SourceCompletionProvider.
//
func (completion *Completion) Providers() []CompletionProviderer {
	var _arg0 *C.GtkSourceCompletion // out
	var _cret *C.GList               // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))

	_cret = C.gtk_source_completion_get_providers(_arg0)
	runtime.KeepAlive(completion)

	var _list []CompletionProviderer // out

	_list = make([]CompletionProviderer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkSourceCompletionProvider)(v)
		var dst CompletionProviderer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtksource.CompletionProviderer is nil")
			}

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(CompletionProviderer)
				return ok
			})
			rv, ok := casted.(CompletionProviderer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtksource.CompletionProviderer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// View associated with completion, or NULL if the view has been destroyed.
//
// The function returns the following values:
//
//    - view (optional) associated with completion, or NULL.
//
func (completion *Completion) View() *View {
	var _arg0 *C.GtkSourceCompletion // out
	var _cret *C.GtkSourceView       // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))

	_cret = C.gtk_source_completion_get_view(_arg0)
	runtime.KeepAlive(completion)

	var _view *View // out

	if _cret != nil {
		_view = wrapView(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _view
}

// Hide hides the completion if it is active (visible).
func (completion *Completion) Hide() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))

	C.gtk_source_completion_hide(_arg0)
	runtime.KeepAlive(completion)
}

// RemoveProvider: remove provider from the completion.
//
// The function takes the following parameters:
//
//    - provider: SourceCompletionProvider.
//
func (completion *Completion) RemoveProvider(provider CompletionProviderer) error {
	var _arg0 *C.GtkSourceCompletion         // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _cerr *C.GError                      // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(provider.Native()))

	C.gtk_source_completion_remove_provider(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(provider)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Start starts a new completion with the specified SourceCompletionContext and
// a list of potential candidate providers for completion.
//
// It can be convenient for showing a completion on-the-fly, without the need to
// add or remove providers to the SourceCompletion.
//
// Another solution is to add providers with
// gtk_source_completion_add_provider(), and implement
// gtk_source_completion_provider_match() for each provider.
//
// The function takes the following parameters:
//
//    - providers (optional): a list of SourceCompletionProvider, or NULL.
//    - context which to start the completion.
//
// The function returns the following values:
//
//    - ok: TRUE if it was possible to the show completion window.
//
func (completion *Completion) Start(providers []CompletionProviderer, context *CompletionContext) bool {
	var _arg0 *C.GtkSourceCompletion        // out
	var _arg1 *C.GList                      // out
	var _arg2 *C.GtkSourceCompletionContext // out
	var _cret C.gboolean                    // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))
	if providers != nil {
		for i := len(providers) - 1; i >= 0; i-- {
			src := providers[i]
			var dst *C.GtkSourceCompletionProvider // out
			dst = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(src.Native()))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	_arg2 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(context.Native()))

	_cret = C.gtk_source_completion_start(_arg0, _arg1, _arg2)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(providers)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnblockInteractive: unblock interactive completion. This can be used after
// using gtk_source_completion_block_interactive() to enable interactive
// completion again.
func (completion *Completion) UnblockInteractive() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(completion.Native()))

	C.gtk_source_completion_unblock_interactive(_arg0)
	runtime.KeepAlive(completion)
}
