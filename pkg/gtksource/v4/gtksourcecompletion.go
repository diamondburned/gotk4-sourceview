// Code generated by girgen. DO NOT EDIT.

package gtksource

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtksourceview/gtksource.h>
// extern void _gotk4_gtksource4_Completion_ConnectShow(gpointer, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectPopulateContext(gpointer, GtkSourceCompletionContext*, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectMovePage(gpointer, GtkScrollStep, gint, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectMoveCursor(gpointer, GtkScrollStep, gint, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectHide(gpointer, guintptr);
// extern void _gotk4_gtksource4_Completion_ConnectActivateProposal(gpointer, guintptr);
// extern void _gotk4_gtksource4_CompletionClass_show(GtkSourceCompletion*);
// extern void _gotk4_gtksource4_CompletionClass_populate_context(GtkSourceCompletion*, GtkSourceCompletionContext*);
// extern void _gotk4_gtksource4_CompletionClass_move_page(GtkSourceCompletion*, GtkScrollStep, gint);
// extern void _gotk4_gtksource4_CompletionClass_move_cursor(GtkSourceCompletion*, GtkScrollStep, gint);
// extern void _gotk4_gtksource4_CompletionClass_hide(GtkSourceCompletion*);
// extern void _gotk4_gtksource4_CompletionClass_activate_proposal(GtkSourceCompletion*);
// extern gboolean _gotk4_gtksource4_CompletionClass_proposal_activated(GtkSourceCompletion*, GtkSourceCompletionProvider*, GtkSourceCompletionProposal*);
// gboolean _gotk4_gtksource4_Completion_virtual_proposal_activated(void* fnptr, GtkSourceCompletion* arg0, GtkSourceCompletionProvider* arg1, GtkSourceCompletionProposal* arg2) {
//   return ((gboolean (*)(GtkSourceCompletion*, GtkSourceCompletionProvider*, GtkSourceCompletionProposal*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtksource4_Completion_virtual_activate_proposal(void* fnptr, GtkSourceCompletion* arg0) {
//   ((void (*)(GtkSourceCompletion*))(fnptr))(arg0);
// };
// void _gotk4_gtksource4_Completion_virtual_hide(void* fnptr, GtkSourceCompletion* arg0) {
//   ((void (*)(GtkSourceCompletion*))(fnptr))(arg0);
// };
// void _gotk4_gtksource4_Completion_virtual_move_cursor(void* fnptr, GtkSourceCompletion* arg0, GtkScrollStep arg1, gint arg2) {
//   ((void (*)(GtkSourceCompletion*, GtkScrollStep, gint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtksource4_Completion_virtual_move_page(void* fnptr, GtkSourceCompletion* arg0, GtkScrollStep arg1, gint arg2) {
//   ((void (*)(GtkSourceCompletion*, GtkScrollStep, gint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtksource4_Completion_virtual_populate_context(void* fnptr, GtkSourceCompletion* arg0, GtkSourceCompletionContext* arg1) {
//   ((void (*)(GtkSourceCompletion*, GtkSourceCompletionContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtksource4_Completion_virtual_show(void* fnptr, GtkSourceCompletion* arg0) {
//   ((void (*)(GtkSourceCompletion*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeCompletionError = coreglib.Type(C.gtk_source_completion_error_get_type())
	GTypeCompletion      = coreglib.Type(C.gtk_source_completion_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCompletionError, F: marshalCompletionError},
		coreglib.TypeMarshaler{T: GTypeCompletion, F: marshalCompletion},
	})
}

// CompletionError: error code used with GTK_SOURCE_COMPLETION_ERROR in a
// #GError returned from a completion-related function.
type CompletionError C.gint

const (
	// SourceCompletionErrorAlreadyBound already bound to the SourceCompletion
	// object.
	SourceCompletionErrorAlreadyBound CompletionError = iota
	// SourceCompletionErrorNotBound is not bound to the SourceCompletion
	// object.
	SourceCompletionErrorNotBound
)

func marshalCompletionError(p uintptr) (interface{}, error) {
	return CompletionError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CompletionError.
func (c CompletionError) String() string {
	switch c {
	case SourceCompletionErrorAlreadyBound:
		return "AlreadyBound"
	case SourceCompletionErrorNotBound:
		return "NotBound"
	default:
		return fmt.Sprintf("CompletionError(%d)", c)
	}
}

// CompletionOverrides contains methods that are overridable.
type CompletionOverrides struct {
	ActivateProposal func()
	// Hide hides the completion if it is active (visible).
	Hide func()
	// The function takes the following parameters:
	//
	//   - step
	//   - num
	//
	MoveCursor func(step gtk.ScrollStep, num int)
	// The function takes the following parameters:
	//
	//   - step
	//   - num
	//
	MovePage func(step gtk.ScrollStep, num int)
	// The function takes the following parameters:
	//
	PopulateContext func(context *CompletionContext)
	// The function takes the following parameters:
	//
	//   - provider
	//   - proposal
	//
	// The function returns the following values:
	//
	ProposalActivated func(provider CompletionProviderer, proposal CompletionProposaller) bool
	Show              func()
}

func defaultCompletionOverrides(v *Completion) CompletionOverrides {
	return CompletionOverrides{
		ActivateProposal:  v.activateProposal,
		Hide:              v.hide,
		MoveCursor:        v.moveCursor,
		MovePage:          v.movePage,
		PopulateContext:   v.populateContext,
		ProposalActivated: v.proposalActivated,
		Show:              v.show,
	}
}

type Completion struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gtk.Buildable
}

var (
	_ coreglib.Objector = (*Completion)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Completion, *CompletionClass, CompletionOverrides](
		GTypeCompletion,
		initCompletionClass,
		wrapCompletion,
		defaultCompletionOverrides,
	)
}

func initCompletionClass(gclass unsafe.Pointer, overrides CompletionOverrides, classInitFunc func(*CompletionClass)) {
	pclass := (*C.GtkSourceCompletionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCompletion))))

	if overrides.ActivateProposal != nil {
		pclass.activate_proposal = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_activate_proposal)
	}

	if overrides.Hide != nil {
		pclass.hide = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_hide)
	}

	if overrides.MoveCursor != nil {
		pclass.move_cursor = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_move_cursor)
	}

	if overrides.MovePage != nil {
		pclass.move_page = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_move_page)
	}

	if overrides.PopulateContext != nil {
		pclass.populate_context = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_populate_context)
	}

	if overrides.ProposalActivated != nil {
		pclass.proposal_activated = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_proposal_activated)
	}

	if overrides.Show != nil {
		pclass.show = (*[0]byte)(C._gotk4_gtksource4_CompletionClass_show)
	}

	if classInitFunc != nil {
		class := (*CompletionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCompletion(obj *coreglib.Object) *Completion {
	return &Completion{
		Object: obj,
		Buildable: gtk.Buildable{
			Object: obj,
		},
	}
}

func marshalCompletion(p uintptr) (interface{}, error) {
	return wrapCompletion(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateProposal signal is a keybinding signal which gets emitted when
// the user initiates a proposal activation.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the proposal activation
// programmatically.
func (completion *Completion) ConnectActivateProposal(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "activate-proposal", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectActivateProposal), f)
}

// ConnectHide is emitted when the completion window is hidden. The default
// handler will actually hide the window.
func (completion *Completion) ConnectHide(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "hide", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectHide), f)
}

// ConnectMoveCursor signal is a keybinding signal which gets emitted when the
// user initiates a cursor movement.
//
// The <keycap>Up</keycap>, <keycap>Down</keycap>, <keycap>PageUp</keycap>,
// <keycap>PageDown</keycap>, <keycap>Home</keycap> and <keycap>End</keycap>
// keys are bound to the normal behavior expected by those keys.
//
// When step is equal to GTK_SCROLL_PAGES, the page size is defined by
// the SourceCompletion:proposal-page-size property. It is used for the
// <keycap>PageDown</keycap> and <keycap>PageUp</keycap> keys.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
func (completion *Completion) ConnectMoveCursor(f func(step gtk.ScrollStep, num int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "move-cursor", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectMoveCursor), f)
}

// ConnectMovePage signal is a keybinding signal which gets emitted when the
// user initiates a page movement (i.e. switches between provider pages).
//
// <keycombo><keycap>Control</keycap><keycap>Left</keycap></keycombo>
// is for going to the previous provider.
// <keycombo><keycap>Control</keycap><keycap>Right</keycap></keycombo>
// is for going to the next provider.
// <keycombo><keycap>Control</keycap><keycap>Home</keycap></keycombo>
// is for displaying all the providers.
// <keycombo><keycap>Control</keycap><keycap>End</keycap></keycombo> is for
// going to the last provider.
//
// When step is equal to K_SCROLL_PAGES, the page size is defined by the
// SourceCompletion:provider-page-size property.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the page selection
// programmatically.
func (completion *Completion) ConnectMovePage(f func(step gtk.ScrollStep, num int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "move-page", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectMovePage), f)
}

// ConnectPopulateContext is emitted just before starting to populate the
// completion with providers. You can use this signal to add additional
// attributes in the context.
func (completion *Completion) ConnectPopulateContext(f func(context *CompletionContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "populate-context", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectPopulateContext), f)
}

// ConnectShow is emitted when the completion window is shown. The default
// handler will actually show the window.
func (completion *Completion) ConnectShow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "show", false, unsafe.Pointer(C._gotk4_gtksource4_Completion_ConnectShow), f)
}

// AddProvider: add a new SourceCompletionProvider to the completion object.
// This will add a reference provider, so make sure to unref your own copy when
// you no longer need it.
//
// The function takes the following parameters:
//
//   - provider: SourceCompletionProvider.
//
func (completion *Completion) AddProvider(provider CompletionProviderer) error {
	var _arg0 *C.GtkSourceCompletion         // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _cerr *C.GError                      // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C.gtk_source_completion_add_provider(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(provider)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// BlockInteractive: block interactive completion. This can be used
// to disable interactive completion when inserting or deleting
// text from the buffer associated with the completion. Use
// gtk_source_completion_unblock_interactive() to enable interactive completion
// again.
//
// This function may be called multiple times. It will continue to block
// interactive completion until gtk_source_completion_unblock_interactive() has
// been called the same number of times.
func (completion *Completion) BlockInteractive() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C.gtk_source_completion_block_interactive(_arg0)
	runtime.KeepAlive(completion)
}

// CreateContext: create a new SourceCompletionContext for completion.
// The position where the completion occurs can be specified by position.
// If position is NULL, the current cursor position will be used.
//
// The function takes the following parameters:
//
//   - position (optional) or NULL.
//
// The function returns the following values:
//
//   - completionContext: new SourceCompletionContext. The reference
//     being returned is a 'floating' reference, so if you invoke
//     gtk_source_completion_start() with this context you don't need to unref
//     it.
//
func (completion *Completion) CreateContext(position *gtk.TextIter) *CompletionContext {
	var _arg0 *C.GtkSourceCompletion        // out
	var _arg1 *C.GtkTextIter                // out
	var _cret *C.GtkSourceCompletionContext // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if position != nil {
		_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(position)))
	}

	_cret = C.gtk_source_completion_create_context(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(position)

	var _completionContext *CompletionContext // out

	_completionContext = wrapCompletionContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _completionContext
}

// InfoWindow: info widget is the window where the completion displays optional
// extra information of the proposal.
//
// The function returns the following values:
//
//   - completionInfo window associated with completion.
//
func (completion *Completion) InfoWindow() *CompletionInfo {
	var _arg0 *C.GtkSourceCompletion     // out
	var _cret *C.GtkSourceCompletionInfo // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_source_completion_get_info_window(_arg0)
	runtime.KeepAlive(completion)

	var _completionInfo *CompletionInfo // out

	_completionInfo = wrapCompletionInfo(coreglib.Take(unsafe.Pointer(_cret)))

	return _completionInfo
}

// Providers: get list of providers registered on completion. The returned list
// is owned by the completion and should not be freed.
//
// The function returns the following values:
//
//   - list of SourceCompletionProvider.
//
func (completion *Completion) Providers() []*CompletionProvider {
	var _arg0 *C.GtkSourceCompletion // out
	var _cret *C.GList               // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_source_completion_get_providers(_arg0)
	runtime.KeepAlive(completion)

	var _list []*CompletionProvider // out

	_list = make([]*CompletionProvider, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkSourceCompletionProvider)(v)
		var dst *CompletionProvider // out
		dst = wrapCompletionProvider(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// View associated with completion, or NULL if the view has been destroyed.
//
// The function returns the following values:
//
//   - view (optional) associated with completion, or NULL.
//
func (completion *Completion) View() *View {
	var _arg0 *C.GtkSourceCompletion // out
	var _cret *C.GtkSourceView       // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_source_completion_get_view(_arg0)
	runtime.KeepAlive(completion)

	var _view *View // out

	if _cret != nil {
		_view = wrapView(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _view
}

// Hide hides the completion if it is active (visible).
func (completion *Completion) Hide() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C.gtk_source_completion_hide(_arg0)
	runtime.KeepAlive(completion)
}

// RemoveProvider: remove provider from the completion.
//
// The function takes the following parameters:
//
//   - provider: SourceCompletionProvider.
//
func (completion *Completion) RemoveProvider(provider CompletionProviderer) error {
	var _arg0 *C.GtkSourceCompletion         // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _cerr *C.GError                      // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C.gtk_source_completion_remove_provider(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(provider)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Start starts a new completion with the specified SourceCompletionContext and
// a list of potential candidate providers for completion.
//
// It can be convenient for showing a completion on-the-fly, without the need to
// add or remove providers to the SourceCompletion.
//
// Another solution is to add providers with
// gtk_source_completion_add_provider(), and implement
// gtk_source_completion_provider_match() for each provider.
//
// The function takes the following parameters:
//
//   - providers (optional): a list of SourceCompletionProvider, or NULL.
//   - context which to start the completion.
//
// The function returns the following values:
//
//   - ok: TRUE if it was possible to the show completion window.
//
func (completion *Completion) Start(providers []CompletionProviderer, context *CompletionContext) bool {
	var _arg0 *C.GtkSourceCompletion        // out
	var _arg1 *C.GList                      // out
	var _arg2 *C.GtkSourceCompletionContext // out
	var _cret C.gboolean                    // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if providers != nil {
		for i := len(providers) - 1; i >= 0; i-- {
			src := providers[i]
			var dst *C.GtkSourceCompletionProvider // out
			dst = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(coreglib.InternObject(src).Native()))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	_arg2 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_source_completion_start(_arg0, _arg1, _arg2)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(providers)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnblockInteractive: unblock interactive completion. This can be used after
// using gtk_source_completion_block_interactive() to enable interactive
// completion again.
func (completion *Completion) UnblockInteractive() {
	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C.gtk_source_completion_unblock_interactive(_arg0)
	runtime.KeepAlive(completion)
}

func (completion *Completion) activateProposal() {
	gclass := (*C.GtkSourceCompletionClass)(coreglib.PeekParentClass(completion))
	fnarg := gclass.activate_proposal

	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C._gotk4_gtksource4_Completion_virtual_activate_proposal(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(completion)
}

// Hide hides the completion if it is active (visible).
func (completion *Completion) hide() {
	gclass := (*C.GtkSourceCompletionClass)(coreglib.PeekParentClass(completion))
	fnarg := gclass.hide

	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C._gotk4_gtksource4_Completion_virtual_hide(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(completion)
}

// The function takes the following parameters:
//
//   - step
//   - num
//
func (completion *Completion) moveCursor(step gtk.ScrollStep, num int) {
	gclass := (*C.GtkSourceCompletionClass)(coreglib.PeekParentClass(completion))
	fnarg := gclass.move_cursor

	var _arg0 *C.GtkSourceCompletion // out
	var _arg1 C.GtkScrollStep        // out
	var _arg2 C.gint                 // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.GtkScrollStep(step)
	_arg2 = C.gint(num)

	C._gotk4_gtksource4_Completion_virtual_move_cursor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(step)
	runtime.KeepAlive(num)
}

// The function takes the following parameters:
//
//   - step
//   - num
//
func (completion *Completion) movePage(step gtk.ScrollStep, num int) {
	gclass := (*C.GtkSourceCompletionClass)(coreglib.PeekParentClass(completion))
	fnarg := gclass.move_page

	var _arg0 *C.GtkSourceCompletion // out
	var _arg1 C.GtkScrollStep        // out
	var _arg2 C.gint                 // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.GtkScrollStep(step)
	_arg2 = C.gint(num)

	C._gotk4_gtksource4_Completion_virtual_move_page(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(step)
	runtime.KeepAlive(num)
}

// The function takes the following parameters:
//
func (completion *Completion) populateContext(context *CompletionContext) {
	gclass := (*C.GtkSourceCompletionClass)(coreglib.PeekParentClass(completion))
	fnarg := gclass.populate_context

	var _arg0 *C.GtkSourceCompletion        // out
	var _arg1 *C.GtkSourceCompletionContext // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = (*C.GtkSourceCompletionContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtksource4_Completion_virtual_populate_context(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(context)
}

// The function takes the following parameters:
//
//   - provider
//   - proposal
//
// The function returns the following values:
//
func (completion *Completion) proposalActivated(provider CompletionProviderer, proposal CompletionProposaller) bool {
	gclass := (*C.GtkSourceCompletionClass)(coreglib.PeekParentClass(completion))
	fnarg := gclass.proposal_activated

	var _arg0 *C.GtkSourceCompletion         // out
	var _arg1 *C.GtkSourceCompletionProvider // out
	var _arg2 *C.GtkSourceCompletionProposal // out
	var _cret C.gboolean                     // in

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = (*C.GtkSourceCompletionProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg2 = (*C.GtkSourceCompletionProposal)(unsafe.Pointer(coreglib.InternObject(proposal).Native()))

	_cret = C._gotk4_gtksource4_Completion_virtual_proposal_activated(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(proposal)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (completion *Completion) show() {
	gclass := (*C.GtkSourceCompletionClass)(coreglib.PeekParentClass(completion))
	fnarg := gclass.show

	var _arg0 *C.GtkSourceCompletion // out

	_arg0 = (*C.GtkSourceCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C._gotk4_gtksource4_Completion_virtual_show(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(completion)
}

// CompletionClass: instance of this type is always passed by reference.
type CompletionClass struct {
	*completionClass
}

// completionClass is the struct that's finalized.
type completionClass struct {
	native *C.GtkSourceCompletionClass
}

func (c *CompletionClass) Padding() [20]unsafe.Pointer {
	valptr := &c.native.padding
	var _v [20]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 20; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}
